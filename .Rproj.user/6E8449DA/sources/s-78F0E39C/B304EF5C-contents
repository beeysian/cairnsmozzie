#Written by SMB
#Created 6/6/18
#Last edited 20/1/19 : cleaning up commented out code and implementing CI
library(dplyr)
library(rbenchmark)
library(progress) #progress bar for for loop
library(magrittr)
library(data.table)
library(sp) #for the boundary check when dealing with mozzie dispersal
library(truncnorm) #for parameter sampling from the truncated normal (needed for ABC step)
library(flexsurv) #used for the Gompertz distribution for age distribution
library(geosphere) #used for distance and dispersal calculations
library(MCMCpack) #used for dirichlet distribution samples

#These packages are for plotting
library(ggplot2)
library(gganimate)
library(gifski)

#---- functions

##--Test functions for initial age distribution: CHANGE

initJuvStage <- function(age){
  if(age >= 0 & age <= 5){
    stage <- 1
  }
  else if(age > 5 & age <= 11){
    stage <- 2
  }
  else{
    stage <- 3
  }
  return(stage)
}

initAdultAge <- function(x){
  age <- 13 + rgeom(1,0.1)
  return(age)
}


##---End test functions

##---Calculations----

#29/1/19: is this function necessary? Can just take rid of it?
sampleClutchSize <- function(x){
  if(x == 0){
    clSize <- round(rnorm(1,mean=120,sd=7),0) #values from literature
  }else{
    clSize <- round(rnorm(1,mean=70,sd=5),0) #values from literature
  }
return(clSize)
}

#29/1/19: is this function necessary? remove it (also this is wrong i think)
resizeClutch <- function(clutchSize,alpha){
  newSize <- rbinom(1,size=clutchSize, prob=(1-alpha))

  return(newSize)
}


findInitMozziePosition <- function(boundaryDat,n){
  #generates n randomly generated points to spawn mosquitoes at
  #includes boundary check: if it finds some out-of-bound points (possible due to irregularity of polygon), will generate until appropriate
  ##points are found
  #this uses package sp
  #creating points
  i <- -1
  while(i == -1){
    polyg <- Polygon(boundaryDat)
    samplePts <- spsample(polyg, n, type="random") #see documentation for other options for 'type'
    #check if points are in bounds:
    if(sum(point.in.polygon(samplePts$x,samplePts$y,boundaryDat$Long,boundaryDat$Lat)) >= n){
      i <- 0
      posdf <- cbind(lat=samplePts$y,long=samplePts$x)
      return(posdf)
    }
  }
}

#29/1/19: Is this function necessary? maybe "initial" age distribution is determined by burn-in?
initAgeDistn <- function (x){
  #calculates ages for each initial adult mosquito according to the initial age structure model mentioned in the report (exponential model)


}

randomDispersal <-function(lat,long, lambda){
  #We calculate 'd', the distance travelled, and 'theta', the direction travelled
  #This is then converted to a new lat & long
  d <- rexp(1,lambda) #formula given in documentation
  thetad <- runif(1,0,2*pi) #formula given in documentation - distance in radians
  ratio <- d/(1000*6371.01) #ratio between distance and the radius of the earth

  latrad <- (lat*pi)/180 #converting from degrees to radians
  longrad <- (long*pi)/180
  thetarad <- (thetad*pi)/180

  latconv <- asin(sin(latrad)*cos(ratio)+cos(latrad)*sin(ratio)*cos(thetarad))
  longconv <- longrad+atan2(sin(thetarad)*cos(latrad)*sin(ratio), cos(ratio)-sin(latrad)*sin(longrad))

  newlat <- (latconv*180)/pi #converting from radians to degrees
  newlong <- (longconv*180)/pi

  #CHECK boundaries
  return(list(lat=newlat, long=newlong))
}


randomRANDOMDispersal<- function(lat,long){
  #randomDispersal is only dispersing along the line so this is just for ANZIAM
  #here they are actually dispersing randomly.
  #let's just draw a 100m squared box around each mosquito and have them disperse somewhere within there.
  position <- as.numeric(c("lat" = lat, "long" = long))

  #CHANGE: boundary widened for testing purposes
  #bdary <- c("latmin" = lat-0.001, "latmax" = lat+0.001, "longmin" = long-0.001 , "longmax" = long+0.001) #CHANGE- magic number is a mozzie i chose randomly
  newlat <- runif(1,lat-0.001, lat+0.001)
  newlong <- runif(1,long-0.001, long+0.001)

  return(list(lat=newlat, long=newlong))
}

temperatureChart <- function(mindf, maxdf, noTimeSteps){
  #Calculate the average daily temperature over the simulation period

  oct <- rowMeans(cbind(mindf$Oct,maxdf$Oct)) #gets average daily temperatures across october
  nov <- rowMeans(cbind(mindf$Nov,maxdf$Nov)) #average daily temperatures across nov
  dec <- rowMeans(cbind(mindf$Dec,maxdf$Dec)) #average daily temps across dec

  dailyTemps <- c(oct,nov,dec)
  dailyTemps <- dailyTemps[which(dailyTemps!=-1)] #-1 is our "NAN" entry, eg Nov 31st
  dailyTemps <- dailyTemps[1:(noTimeSteps+1)] #plus 1 is beacuse we want a 0th timestep for initialisation

  return(dailyTemps)
}

initializeEnzyme <- function(dailyTemps){
  #Initialises the Enzyme Kinetic model for the model run
  #Since the update in EKS changes the same amount for every agent in the same lifetime stage on the same timestep, we make a "chart" of these values
  #Notes for the constants.txt file:
  ##KELV_CONV: BOM data is in degrees Celcius, enzyme kinetic calculations require degrees Kelvin, conversion is temp in C + 273.15
  ##R: universal gas constant used in EKM calculations
  #Parameters for EKS are from Focks et al (1993)
  ##E: Embryogenesis (egg) stage, L: Larval development stage, P: Pupal development stage, G: Gonotrophic cycle stage

  kelvinTemps <- dailyTemps + const$KELV_CONV #the EKM requires temperatures to be in Kelvin so we need to convert to Kelvin

  #EKM development charts for each stage of the development cycle: egg, larval, pupal and gonotrophic (adult reproductive). From Focks et. al 1993
  #Since the equation assumes a timestep of hours, we multiply by 24 since our timestep is in days
  EKM_egg <- 24*((const$RHO_E*(kelvinTemps/298)*exp((const$HA_E/const$R)*((1/298) - (1/kelvinTemps))))/(1 + exp((const$HH_E/const$R)*(((1/const$THALF_E)-(1/kelvinTemps))))))
  EKM_larval <- 24*((const$RHO_L*(kelvinTemps/298)*exp((const$HA_L/const$R)*((1/298) - (1/kelvinTemps))))/(1 + exp((const$HH_L/const$R)*(((1/const$THALF_L)-(1/kelvinTemps))))))
  EKM_pupal <- 24*((const$RHO_P*(kelvinTemps/298)*exp((const$HA_P/const$R)*((1/298) - (1/kelvinTemps))))/(1 + exp((const$HH_P/const$R)*(((1/const$THALF_P)-(1/kelvinTemps))))))
  EKM_gono <- 24*((const$RHO_G*(kelvinTemps/298)*exp((const$HA_G/const$R)*((1/298) - (1/kelvinTemps))))/(1 + exp((const$HH_G/const$R)*(((1/const$THALF_G)-(1/kelvinTemps))))))

  EKM_chart <- as.data.table(cbind(EKM_egg,EKM_larval,EKM_pupal,EKM_gono))

  return(EKM_chart)
}

updateEnzyme <- function(type,time){
#Updates the enzyme kinetic score (EKS) for a mosquito
  #inputs: type- the stage the agent is in, time- the timestep we are at
#It is highly recommended that you read the documentation on what the EKS is used for, the formula for the EKS and how it is updated as there is too much theory to be explained in code comments

  if(type == 1){
    EKSUpdate <- EKMChart[[1]][time]
  }
  else if(type == 2){
    EKSUpdate <- EKMChart[[2]][time]
  }

  else if(type == 3){
    EKSUpdate <- EKMChart[[3]][time]
  } else{
    EKSUpdate <- EKMChart[[4]][time]
  }

  return(EKSUpdate)
}

findMate <- function(femID,k){
  #Finds a mate for a female mosquito of breeding age
  #Output: ID of mate (-1 if does not find a mate)
  #Recall that in order to mate, a female mozzie must have an Enzyme Kinetic Score (EKS) between 1.2 and 1.8 inclusive
  #Please read documentation on this function as there is too much to explain to put in comments
  newMate <- -1 #Function returns -1 if it does not find a mate

  #1) Draw an imaginary square around the mosquito of "radius" ~11m
  position <- as.numeric(c("lat" = mozziedf$lat[femID], "long" = mozziedf$long[femID]))

  #CHANGE: boundary widened for testing purposes
  bdary <- c("latmin" = position[1]-0.0011, "latmax" = position[1]+0.0011, "longmin" = position[2]-0.0011 , "longmax" = position[2]+0.0011) #CHANGE- magic number is a mozzie i chose randomly

  #Finding all possible males within this region that can mate with this female. Note that males can mate with more than one female

  #CHECK EKS of males that can mate?
  possibleMates <- which(mozziedf$lat >= bdary["latmin"] & mozziedf$lat <= bdary["latmax"] & mozziedf$long >= bdary["longmin"] & mozziedf$long <= bdary["longmax"] & mozziedf$gender == 0)
  noBachelors <- length(possibleMates)
  #print(paste0("noBachelors: ",noBachelors))
  if(noBachelors == 0){
    #return(newMate) #No new mate found
    newMate <- -1
   # print(paste0(femID, " no mate found"))
  }
  else if(noBachelors == 1){
    if(mozziedf[possibleMates]$gonoCycle >= max_daily_mates){
      newMate <- -1
      #return(newMate) #even though there is only one male, he has mated too much today
      #print(paste0(femID, " 1 mate found, unsuitable"))
      }
    else{
      newMate <- as.integer(possibleMates)
      mozziedf$gonoCycle[newMate] <<- mozziedf$gonoCycle[newMate] + 1

      #return(mozziedf$ID[possibleMates]) #New mate is just the single male they found
      #print(paste0(femID, " 1 mate found"))
      }
  }
  else{

    if(length(which(mozziedf[possibleMates]$gonoCycle >= max_daily_mates)) == 0){
      newMate <- sample(possibleMates)[1] #this randomly permutes the list of possible mates and then picks the one at the top of the pile
      mozziedf$gonoCycle[newMate] <<- mozziedf$gonoCycle[newMate] + 1 #increment number of mates by 1
      #print(paste0(femID, " multiple mates, all ok"))
    }
    else{
      possibleMates <- possibleMates[-(which(mozziedf[possibleMates]$gonoCycle >= max_daily_mates))] #remove males who have mated more than max_daily_mates in a day

      #now we have one more condition to check for: if we drop some males from "possibleMates" we might end up dropping them all, so if we dropped them all we return -1
      if(length(possibleMates) == 0){
        #print(paste0(femID, " multiple mates, had to drop some AND then ended up with none"))
        newMate <- 1
      }
      else{
        newMate <- sample(possibleMates)[1] #this randomly permutes the list of possible mates and then picks the one at the top of the pile
        mozziedf$gonoCycle[newMate] <<- mozziedf$gonoCycle[newMate] + 1 #increment number of mates by 1
        #print(paste0(femID, " multiple mates, had to drop some"))
      }
    }

  }
  return(newMate)
}


##---End calculations---

##---Constructors-----

initialiseRelease <- function(noReleased, pmale,lat,long){
  #simulates a release of Wolbachia-carrying mosquitoes. Releases in this experiment are always adults.
propInfRelease <- 0.98 #proportion of released mosquitoes that carry Wolbachia (CHECK: get actual value from WMP)

#much of this is copied from the 'initialiseAdults' function so make sure if changes are made there that they're reflected here

noVariables <- 15 #number of variables used to track state of mozzie minus 2 (lat & long). this is so I make sure to remember to change it as necessary
#18/7: change df so we just have a numeric age for mosquitoes rather than timeBirth/timeAdult/timeDeath
df <- setNames(data.frame(matrix(ncol = noVariables, nrow = noReleased)), c("ID", "gender", "lat","long","mateID", "enzyme","age","gonoCycle","timeDeath","typeDeath","whereTrapped","motherID","fatherID","infStatus","releaseLoc"))

df$gender <- lapply(df$gender, function(x) x<- rbinom(1,1,1-pmale)) #probability of male is calculated above. since female mozzies are represented by 1 (a success) we have 1-pmale
df$ID <- (max(mozziedf$ID)+1):((max(mozziedf$ID))+noReleased) #unique ID for each mosquito #CHECK

#df$age <- lapply(df$age, function (x) x<-round(rtruncnorm(1,mean=20,sd=2,a=14,b=30)))
df$age <- lapply(df$age, function(x) x <- round(runif(1,min=18,max=21),0))
df$motherID <- -1
df$fatherID <- -1
df$releaseLoc <- -1 #CHECK this needs to be changed to their actual release location

#lat should be 145 and long should be -16 but I have the rest of the code fucked up: CHANGE later
#df$lat <- 145.760 #CHANGE: this is for testing. should be read in from data
#df$long <- -16.918 #CHANGE: this is for testing only#

#df$long <- 145.760
#df$lat <- -16.918
df$long <- long
df$lat <- lat
df$timeDeath <- -1
df$typeDeath <- -1
df$infStatus <- lapply(df$infStatus, function(x) x <-rbinom(1,1,propInfRelease))
#df$infStatus <- 0 #since these are wild mosquitoes, none are infected (from Carla's notes)
#infStatus: 1 for wolbachia, 0 for no wolbachia, -1 for CI
df$whereTrapped <- -1

df$mateID <- -1

df$enzyme <- lapply(df$enzyme, function(x) x <- runif(1, min=0, max=1))  #CHANGE: want to use initial age distribution to get spread of initial enzymes

df$gonoCycle[which(df$gender == 0)] <- 0 #males start off at 0 because 'gonoCycle' tracks number of mating events in a day for males
df$gonoCycle[which(df$gender == 1 & df$age >=14 & df$age < 20)] <- 0
df$gonoCycle[which(df$gender == 1 & df$age >=20 & df$age < 26)] <- 1
df$gonoCycle[which(df$gender == 1 & df$age >=26)] <- 2



return(df)

}

initialiseAdults <- function(N,pmale){
  #note that a lot of these values will be -1 or 0 for the initial population of mosquitoes- eg the initial mozzies don't have parents that are in our model
  #initialise df
  noVariables <- 13 #number of variables used to track state of mozzie INCLUDING lat & long (differs from df in initialiseAdults). this is so I make sure to remember to change it as necessary
 #18/7: change df so we just have a numeric age for mosquitoes rather than timeBirth/timeAdult/timeDeath
  df <- setNames(data.frame(matrix(ncol = noVariables, nrow = N)), c("ID", "gender","mateID", "enzyme","age","gonoCycle","timeDeath","typeDeath","whereTrapped","motherID","fatherID","infStatus","releaseLoc"))

  df$gender <- lapply(df$gender, function(x) x<- rbinom(1,1,1-pmale)) #probability of male is calculated above. since female mozzies are represented by 1 (a success) we have 1-pmale
  df$ID <- 1:N #unique ID for each mosquito

  #since these are initial adults some of these initialisations are irregular/exceptions
  #df$timeBirth <- 0
  #df$timeAdult <- 0
  df$age <- lapply(df$age, function (x) x<-round(rtruncnorm(1,mean=20,sd=2,a=14,b=30)))
  df$motherID <- -1
  df$fatherID <- -1
  df$releaseLoc <- -1
  df$timeDeath <- -1
  df$typeDeath <- -1
  df$infStatus <- 0 #since these are wild mosquitoes, none are infected (from Carla's notes)
 #infStatus: 1 for wolbachia, 0 for no wolbachia, -1 for CI
  df$whereTrapped <- -1

  #males don't have mates in this model, so set mateID = -1
  #df$mateID[df$gender == 0] <- -1
  #Update 24/7: just initialise every mozzie with mateID = -1, female mozzies that mate will later get a positive mateID
  df$mateID <- -1

  df$enzyme <- lapply(df$enzyme, function(x) x <- runif(1, min=0, max=1))  #CHANGE: want to use initial age distribution to get spread of initial enzymes

  #FIX this shit and make it work better :(
  df$gonoCycle[which(df$gender == 0)] <- 0 #males start off at 0 because 'gonoCycle' tracks number of mating events in a day for males
  df$gonoCycle[which(df$gender == 1 & df$age >=14 & df$age < 20)] <- 0
  df$gonoCycle[which(df$gender == 1 & df$age >=20 & df$age < 26)] <- 1
  df$gonoCycle[which(df$gender == 1 & df$age >=26)] <- 2

  #initial position of each mosquito, then combine with rest of dataframe
  posdf <- findInitMozziePosition(boundaryDat,N)
  df<- cbind(df,posdf)

  return(df)
}

initialiseJuveniles <- function(Njuv){
  df <- setNames(data.frame(matrix(ncol = 10, nrow = Njuv)), c("mother","father","age","stage" ,"infProb", "lat","long","clutchSize","enzyme","pDeath"))
  #no ID, gender, etc until they become adults
  df$mother <- -1
  df$father <- -1
  df$age <- lapply(df$age, function(x) x <- round(runif(1, min=0, max=14),0)) #Uniform between 0 and 14 as a quick fix- FIX
  df$stage <- mapply(FUN = initJuvStage, df$age)

  #this can be replaced with a binary for inf/noninf since fringe cases lead to CI
  df$infProb <- 0 #dummy setup, this will be sampled in RABC (also need correct value from Carla)

  #df$clutchSize <- lapply(df$clutchSize, function (x) x <- sampleClutchSize(0))

  df$clutchSize <- eta_1 #since these will always be wild type
  df$enzyme <- lapply(df$enzyme, function(x) x <- runif(1, min=0, max=0.95)) #CHANGE: this should not be uniform
  df$pDeath <- alpha #fix this. see removeNatDeath in Carla's code

  ##BUT for the moment we're just using the same method as the adult lat/long to get working prototype
  df$lat <- lapply(df$lat, function (x) x<-round(runif(1, min = min(boundaryDat$Lat), max = max(boundaryDat$Lat)),6))
  df$long <- lapply(df$long, function (x) x<-round(runif(1, min = min(boundaryDat$Long), max = max(boundaryDat$Long)),6))

return(df)
}

initialiseEggs <- function(toLay){
  #Mothers laying clutches of eggs
  #Creates new entries for the data table of new juveniles
  #df <- setNames(data.frame(matrix(ncol = 8, nrow = Njuv)), c("mother","age", "infProb", "lat","long","clutchSize","enzyme","pDeath"))
  #Input: vector of IDs of mums about to lay eggs
  noMothers <- length(toLay)
  eggsdt <- data.table(mother = numeric(noMothers), father = numeric(noMothers), motherStatus = numeric(noMothers), fatherStatus = numeric(noMothers), age = numeric(noMothers), stage = numeric(noMothers), infProb = numeric(noMothers) , lat = double(noMothers), long = double(noMothers), clutchSize =  numeric(noMothers), enzyme = double(noMothers), pDeath = double(noMothers))
  eggsdt$mother <- mozziedf$ID[toLay] #ID of mother
  eggsdt$father <- mozziedf$mateID[toLay] #ID of father

  eggsdt$age <- 0 #because they're new!
  eggsdt$stage <- 1 #because they're eggs!
  eggsdt$lat <- mozziedf$lat[toLay] #mother's position
  eggsdt$long <- mozziedf$long[toLay] #mother's position

  #Clutch sizes- they differ between non-carrier (eta_1) and carrier mothers (eta_2)
  #Note eta_1 and eta_2 are RABC parameters (sampled at the beginning of the simulation) so the clutch sizes here are to be fixed
  eggsdt[eggsdt=="NULL"] <- 0
  eggsdt <- na.omit(eggsdt) #CHANGE THIS it shouldnt be happening
  #eggsdt <- eggsdt[complete.cases(eggsdt$infProb),]
  eggsdt$clutchSize[which(mozziedf$infStatus[toLay] == 1)] <- eta_2 #finish
  eggsdt$clutchSize[which(mozziedf$infStatus[toLay] == 0)] <- eta_1 #finish

  eggsdt$enzyme <- 0 #Since they are new eggs, they haven't had the "chance" to accumulate enzyme yet

  #----CI- FINISH
  #eggsdt$fatherStatus <- mozziedf$infStatus[eggsdt$father] #should give a list of 1s and 0s corresponding to their father's Wolbachia status
  #eggsdt$motherStatus <- mozziedf$infStatus[eggsdt$mother] #same but for mother
  eggsdt$fatherStatus <- mozziedf$infStatus[which(mozziedf$ID %in% mozziedf$mateID[toLay])] #should give a list of 1s and 0s corresponding to their father's Wolbachia status
  eggsdt$motherStatus <- mozziedf$infStatus[toLay] #same but for mother



  #If mother is a Wolbachia carrier then offspring should be (with probability p_1)
  eggsdt$infProb[which(eggsdt$motherStatus == 1)] <- (1-p_1)
  eggsdt$pDeath[which(eggsdt$motherStatus == 1)] <- 0.01 #natural death rate

  #FIX : HACKY FOR LOOP for ANZIAM 2/2/19

  motheruninf <- which(eggsdt$motherStatus == 0)

  for(i in 1:length(motheruninf)){
    if(eggsdt$fatherStatus[motheruninf[i]] == 0){
      eggsdt$infProb[i] <- 0
      eggsdt$pDeath <- alpha
    }
    else if(eggsdt$fatherStatus[motheruninf[i]] == 1){
      eggsdt$infProb[i] <- -1
      eggsdt$pDeath[i] <- -1
    }
    else{
      #error handling case; offspring are just wild CHECK
      eggsdt$infProb[i] <- 0
      eggsdt$pDeath <- alpha
    }
  }

  #If mother is not a Wolbachia carrier and father is not a Wolbachia carrier, offspring do not have Wolbachia
  #eggsdt$infProb[which(eggsdt$motherStatus == 0 && eggsdt$fatherStatus == 0)] <- 0
  #eggsdt$pDeath[which(eggsdt$motherStatus == 0 && eggsdt$fatherStatus == 0)] <- alpha #natural death rate

  #If mother is not a Wolbachia carrier and father is a Wolbachia carrier, we have CI (death)
  #eggsdt$infProb[which(eggsdt$motherStatus == 0 && eggsdt$fatherStatus == 1)] <- -1
  #eggsdt$pDeath[which(eggsdt$motherStatus == 0 && eggsdt$fatherStatus == 1)] <- -1 #because they're all dead. Set to -1 instead of 1 so we know it's a nonsense number

  #Get rid of "extra information" in data table that we no longer need
  eggsdt <- eggsdt[,c("motherStatus","fatherStatus") := NULL]

  #-------- Old code below
  ##Which mothers carry Wolbachia and which do not?
  #infMothers <- toLay[which(mozziedf$infStatus[toLay] == 1)]
  #noninfMothers <- toLay[which(mozziedf$infStatus[toLay] == 0)]

  #if mother is a Wolbachia carrier then offspring should be (with probability p_1)
  #if(length(infMothers) != 0){
  #  eggsdt$infProb[which(mozziedf$infStatus[infMothers] == 1)] <- p_1 #CHECK/FIX to be whatever the real parameter value is
  #  eggsdt$pDeath[which(mozziedf$infStatus[infMothers] == 1)] <- alpha #The natural death rate
  #}
  #else offspring will 1) either have CI or 2) be uninfected with Wolbachia. We need to determine the father's status
  #else if(length(noninfMothers) != 0){
  #  noninfMothers.mates <- mozziedf$mateID[noninfMothers]
  #  dads <- which(mozziedf$ID %in% noninfMothers.mates) #this gives us the INDEX (NOT THE ID) of each of the dads we have to look at in the dataframe

  #  infDads <- dads[which(mozziedf$infStatus[dads] == 1)] #which dads have Wolbachia
  #  noninfDads <- dads[which(mozziedf$infStatus[dads] == 1)] #which dads do not have Wolbachia

    #If both dad and mum do not have Wolbachia, the offspring will not have Wolbachia
   # if(length(noninfDads) != 0){
  #    eggsdt$infProb[which(noninfDads %in% noninfMothers)]
    #}

    #If mother doesn't have Wolbachia but the father does, offspring die
    #if(length(infDads) != 0){

    #}
  #}


  #29/1/19: I am really tired so doing this in sloooow steps
  #uninfMothers <- which(mozziedf$infStatus[toLay] == 0) #who are our uninfected mothers?
  #uninfMothersMate <- mozziedf$mateID[uninfMothers]


  #fatherStatus <- mozziedf$infStatus[mozziedf$mateID[toLay]]
  #eggsdt$infProb[which(mozziedf$infStatus[toLay] == 1 & )]

  #Probability of infection (carrying Wolbachia)- please see documentation
  #whichNoninf <- which(mozziedf$infStatus[toLay] == 0 & mozziedf$infStatus[mozziedf$mateID[toLay]] == 0)

  return(eggsdt)
}

juvtoAdult <- function(juvID, idStart, pmale,lambda){
  #df <- setNames(data.frame(matrix(ncol = 15, nrow = N)), c("ID", "gender" , "lat", "long","mateID", "enzyme","timeBirth","timeAdult","timeDeath","typeDeath","whereTrapped","motherID","fatherID","infStatus","releaseLoc"))
  dt <- data.table(ID=idStart:(idStart+juvdf$clutchSize[[juvID]]-1), gender=numeric(juvdf$clutchSize[[juvID]]), lat=numeric(juvdf$clutchSize[[juvID]]), long=numeric(juvdf$clutchSize[[juvID]]), mateID=numeric(juvdf$clutchSize[[juvID]]), enzyme=numeric(juvdf$clutchSize[[juvID]]), age=numeric(juvdf$clutchSize[[juvID]]), gonoCycle=numeric(juvdf$clutchSize[[juvID]]) ,timeDeath=numeric(juvdf$clutchSize[[juvID]]) ,typeDeath=numeric(juvdf$clutchSize[[juvID]]), whereTrapped=numeric(juvdf$clutchSize[[juvID]]), motherID=numeric(juvdf$clutchSize[[juvID]]), fatherID=numeric(juvdf$clutchSize[[juvID]]), infStatus=numeric(juvdf$clutchSize[[juvID]]), releaseLoc=numeric(juvdf$clutchSize[[juvID]]))
  dt$gender <- lapply(dt$gender, function(x) x<- rbinom(1,1,1-pmale)) #probability of male is calculated above. since female mozzies are represented by 1 (a success) we have 1-pmale

  #We assume that mozzies disperse a bit from their original position when they hatch
  #CHECK boundaries
  positions <- lapply(1:juvdf$clutchSize[[juvID]], function(x) randomRANDOMDispersal(juvdf$lat[[juvID]],juvdf$long[[juvID]])) #creates a list of lats and longs
  positions <- do.call(rbind,positions)
  dt$lat <- positions[,1]
  dt$long <- positions[,2]

  dt$mateID <- dt$mateID[dt$gender == 0] <- -1 #males don't have mates
  dt$enzyme <- 0 #enzyme resets because they're moving to the next stage
  #dt$timeBirth <- 0 #change
  #dt$timeAdult <- 0 #change
  dt$age <- 0
  #dt$age <- 14 + t
  dt$gonoCycle <- 0 #gonoCycle will start at 0 for everyone when they become an adult
  dt$whereTrapped <- -1

  #dt$motherID <- -1
  #dt$fatherID <- -1

  dt$motherID <- juvdf$mother[[juvID]]
  dt$fatherID <- juvdf$father[[juvID]]

  dt$infStatus <- lapply(dt$infStatus, function(x) x<-rbinom(1,1,juvdf$infProb[juvID]))
  #dt$infStatus <- juvdf$infProb[[juvID]] #FIX
  dt$releaseLoc <- -1
  dt$timeDeath <- -1
  dt$typeDeath <- -1

return(dt)
}
##End Constructors-----

##----- End functions



#----- Read in data files
  boundaryDat <- read.table("New_pp_Bound.txt", header=TRUE) #Boundary data for the boundary of the area used in trial (given as a set of lat/long points)
  #weatherDat <- read.table("BOMdata.txt", header=TRUE) #Weather data over 90 days as provided by BOM
  minTemp <- read.table("cairnsAero_minTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
  maxTemp <- read.table("cairnsAero_maxTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
  const <- read.table("constants.txt", header=TRUE) #constants used for EKM calculations
##---- End reading files

#----- Global constants
# 20/7: Move this into a separate file

#These constants are more for sanity checks
max_age <- 30 #mozzies who reach this age automatically die naturally
max_juv_age <- 14 #juveniles who reach this age automatically become adults
init_prop_inf <- 0 #initial proportion of wild mozzies carrying Wolbachia- we expect this to be 0
max_daily_mates <- 2 #maximum number of mating events a MALE mosquito can have in a day (from literature)

##---- End Global constants

#----- Parameter generation (Will be handled by RABC)
  #lambda <- rgamma(1,shape=0.044,scale=3) #CHECK/CHANGE THIS omg i don't know how the Gamma distribution works
  lambda <- rgamma(1,3,22) #this is the alternative for lambda given in priors.pdf. Seems to give reasonable results with lat/long conversion so tempted to go with
#pmale <- runif(1,0.3,0.7) #can also set to be 0.45
#OR pmale <- rnorm(1,mean=0.5,sd=0.02) ??? check with Carla which one
  pmale <- 0.45 #set at 0.45 for now #proportion of male mosquitoes in wild population
  # k <-  rgamma(1,shape=0.2,scale=0.06) #CHANGE THIS #rate at which probability of mating drops wrt distance of potential mate
  #k <- rgamma(1,1,1/35) #rate at which probability of mating drops wrt distance of potential mate
  k <- rgamma(1,shape=1,scale=1/35)
  phi <- runif(1,0,0.1) #hyperparameter for probability that mozzies are trapped by any given trap
  a <- rtruncnorm(1,mean=0.02,sd=0.01,a=0,b=0.5) #Scale parameter regarding probability of natural death (Gompertz model)
  b <- rtruncnorm(1,mean=0.22,sd=0.05,a=0,b=0.5) #Scale parameter regarding probability of natural death (Gompertz model)
  alpha <- 0.001 #CHANGE #this is for natural death
  p_1 <- runif(1,0,0.05) #parameter for CI (prop. of uninfected larvae given both parents are infected)

  #WMP say that the following two values of eta are wrong/too high: so will put lower ones below
  #eta_1 <- round(rnorm(1,mean=120,sd=7),0) #no. of offspring produced by Wb non-carrier mothers (values from literature)
  #eta_2 <- round(rnorm(1,mean=70,sd=5),0) #no. of offspring produced by Wb carrier mothers (values from literature)

  #To re-iterate, these are MADE UP and need validifying
  eta_1 <- round(rnorm(1,mean=40,sd=7),0) #no. of offspring produced by Wb non-carrier mothers
  eta_2 <- round(rnorm(1,mean=30,sd=5),0) #no. of offspring produced by Wb carrier mothers

##----- end of parameter generation

#----- variable initialisation
  N <- 190 #number of adult mosquitoes at time t=0. To be initialised between 4000 to 20000
  Njuv <- 2 #number of juvenile CLUSTERS (not individuals) at time t=0
  idStart <- N+1 #ID numbers of initial adults will be 1:N, then we start at N+1 for any new adult mosquito within simulation
  noTimeSteps <- 90 #our simulation runs for 90 days
##---- end variable initialisation

#---- calculate charts
  dailyTemps <- temperatureChart(minTemp, maxTemp, noTimeSteps) #chart of average daily temperatures for each day of the simulation
  EKMChart <- initializeEnzyme(dailyTemps) #chart of daily updates for EKS
##---- end chart calculation


#----- initial model construction
##7/6/18: change code so constructs as a data table
  mozziedf <- as.data.table(initialiseAdults(N, pmale)) #initial adult population
  juvdf <- as.data.table(initialiseJuveniles(Njuv)) #initial juvenile population

##---- end initial model construction

  t <- 1
  plot_list <- list() #for animations
 # pb <- progress_bar$new(total = noTimeSteps) #progress bar

  for(t in 1:30){
      #pb$tick() #progress bar
  #---Step 1: Do we have juveniles turning in to adults?---#
    #update 26/10/18
    toAdult <- which(juvdf$stage == 3 & juvdf$enzyme > 0.95)

  #only bother trying to add new adults if there are clutches of age 14
    if((length(toAdult)) != 0){
      newAdultsdt <- mapply(FUN=juvtoAdult,toAdult,idStart,pmale,lambda,SIMPLIFY = FALSE) #make new adults

    #using pipes to get rid of previous two lines
    #let's try and use PIPES
      newAdultsdt %<>% rbindlist() %>% as.data.table()
    #append the new adults to the adult data table
      mozziedf <- rbind(mozziedf,newAdultsdt)

    #delete row(s) of data table corresponding to the clutches that aged into adult mozzies
      juvdf <- juvdf[-toAdult]
      rm(newAdultsdt)
    }

    #---Step 1.5: any juveniles moving to the next development stage?

    #if enzyme > 0.95, move on to the next development stage and reset enzyme score
    if(length(which(juvdf$enzyme > 0.95))){
      #which(juvdf$enzyme > 0.95)
      juvdf[which(juvdf$enzyme > 0.95)]$stage <- juvdf[which(juvdf$enzyme > 0.95)]$stage + 1

      #this gives HELLA warnings- try mapply or lapply or something?
      juvdf[which(juvdf$enzyme > 0.95)]$enzyme <- 0
      #juvdf[which(juvdf$enzyme > 0.95)]$stage <- lapply(juvdf[which(juvdf$enzyme > 0.95)]$stage, function(x) x <- juvdf$enzyme[x] <- 0)
    }

    #---End Step 1.5
    rm(toAdult)
  ##--- End Step 1

  #---Step 2: Producing offspring---#
  #Conditions to be satisfied for a mother to lay a clutch of eggs:
  ## 1) Has a mate
  ## 2) Enzyme Kinetic Score > 1 (should mean that mosquito has a mate)
  ## 3) First egg laying event is at EKS > 1, second at 1.58, third at 2.16, etc. for multiples of 0.58 (from Focks et al '93)

    toLay <- which(mozziedf$gender == 1 & mozziedf$mateID != -1 & ((mozziedf$enzyme >= 1 & mozziedf$gonoCycle == 0) | (mozziedf$enzyme >= 1.58 & mozziedf$gonoCycle == 1) | (mozziedf$enzyme >= 2.16 & mozziedf$gonoCycle == 2)))


   if(length(toLay) != 0){
      newEggsdt <- initialiseEggs(toLay)
      juvdf <- rbind(juvdf,newEggsdt)
      rm(newEggsdt)
    }

    rm(toLay)
  ##--- End Step 2

  #---Step 3: Do we have mosquitoes being trapped (and killed?)---#
  ##--- End Step 3

  #---Step 4: Natural mosquito death (adult and juvenile)---#
  #Juvenile death:

    #CHANGE THIS! maybe just take 10% away when they become adults, this will kill off any clutch in like 10 timesteps

    #alternative alternative way (8/11):
    #fix juv death: want to use exponential distribution

    #The subsetting of juvdf$clutchSize is because we don't reduce clutch size of CI-affected eggs: they're already dead, but we just want to track how many there are so we leave clutchSize alone
    juvdf$clutchSize[which(juvdf$pDeath != -1)] <- mapply(FUN=resizeClutch,juvdf$clutchSize,alpha)



    #system.time(juvdf[,clutchSize := (as.numeric(clutchSize) - as.numeric(rbinom(15,prob=pDeath,n=clutchSize)))]) #this would work if it weren't for the '-'

  ##Adult death:
  #Adults die automatically when they reach age 40
    #CHANGE this to EKS?
    toOldDie <- which(mozziedf$age == max_age & mozziedf$timeDeath == -1) #vector of mosquitoes that will die of old age #CHANGE TO age == 30
    if((length(toOldDie)) != 0){
    #track day that they died (timeDeath) and set typeDeath=0 to denote natural (not trapped) death
      #ADD THE FOLLOWING TWO LINES BACK FOR MAIN SIM
      #mozziedf$typeDeath[toOldDie] <- 0
      #mozziedf$timeDeath[toOldDie] <- t #CHANGE to current timestep when I get that working
      mozziedf <- mozziedf[!toOldDie,]
    }

    #TURNED OFF NATURAL DEATH: CHANGE
    #Also have natural death for adults as per juveniles
    #mozziedf <- mozziedf[!sample(.N, round(alpha*nrow(mozziedf)))]


    #THIS IS WRONG!!!! FIX IT
    #toNatDie <- sample_n(mozziedf, rbinom(1,size=nrow(mozziedf),prob=(1-alpha)))$ID


    #ADD THE FOLLOWING TWO LINES BACK FOR MAIN SIM
    #mozziedf$typeDeath[toNatDie] <- 0
    #mozziedf$timeDeath[toNatDie] <- t #CHANGE to timestep


    #mozziedf <- mozziedf[!toNatDie,]

    rm(toOldDie)
    #rm(toNatDie)
  ##--- End Step 4

  #---Step 5: Mosquito mating---#

    #FIX THIS: inappropriate conditions
    #toMate <- which(mozziedf$gender == 1 & mozziedf$mateID == -1)

    #We only need to find mates for females that don't have mates and haven't laid eggs yet (first gono cycle) and has EKS >= 1 (From Focks)
    toMate <- which((mozziedf$gender == 1 & mozziedf$mateID == -1 & mozziedf$gonoCycle == 0 & mozziedf$enzyme >= 1))


    #toMate <- which(mozziedf$enzyme >= 1.2 & mozziedf$enzyme <= 1.8 & mozziedf$gender == 1 & mozziedf$mateID == -1) #& age = 16?


    if(length(toMate) != 0){
      mozziedf$mateID[toMate] <- mapply(FUN=findMate,toMate,k)
      #try <- mapply(FUN=findMate,toMate,k) #for testing: gives the vector of mate IDs for the bachelorette mosquitoes
    }

    #testmates <- lapply(toMate,FUN=findMate) #only here for testing
    #testmatesmapply <- mapply(FUN=findMate,toMate,k)
    rm(toMate)
    mozziedf$gonoCycle[which(mozziedf$gender == 0)] <- 0 #resetting gonoCycle for the next day: males can only mate 2 a day
  ##--- End Step 5

  #---Step 6: update kinetic enzyme score of each agent---#
    #juvdf$age <- sapply(juvdf$age, function(x) x <- x+1) #maybe change to lapply if this is messing things up

    #not done yet FIX, also keep in mind won't work becasuse time t hasn't been implemented (24/10/18)
    #t = 1
    juvEnzymeUpdate <- mapply(FUN=updateEnzyme,juvdf$stage,t)
    #juvdf$enzyme <- juvdf$enzyme + as.data.frame(juvEnzymeUpdate) #this is a super hacky method. should be like the below two lines but it's not working

    juvdf$enzyme <- as.numeric(juvdf$enzyme) + as.numeric(juvEnzymeUpdate) #this is a super hacky method. should be like the below two lines but it's not working


    mozzieEnzymeUpdate <- mapply(FUN=updateEnzyme,4,t) #adult mosquitoes always update with the same EKM formula, hence are always in "stage 4"
    #mozziedf$enzyme <- mozziedf$enzyme + as.data.frame(mozzieEnzymeUpdate)
    mozziedf$enzyme <- as.numeric(mozziedf$enzyme) + as.numeric(mozzieEnzymeUpdate)
    #  juvdf$enzyme <- lapply(juvdf$enzyme, function(x) x <- updateEnzyme(juvdf[x]$stage,t))
    #juvdf$enzyme <- lapply(juvdf$enzyme, function(x) x <- juvdf[x]$enzyme + updateEnzyme(juvdf[x]$stage,t))

    rm(juvEnzymeUpdate)
    rm(mozzieEnzymeUpdate)
  ##--- End Step 6

  #---Step 7: Migration (happens at time steps 15-17)---#
  ##CHECK boundaries
  ##Determine which mosquitoes are going to migrate
    toMigrate <- which(mozziedf$age == 19 | mozziedf$age == 20 | mozziedf$age == 21) #CHANGE
    if(length(toMigrate) != 0){
      #List of updated lats/longs

      # 31/1/19: UNCOMMENT THE FOLLOWING TWO LINES AFTER ANZIAM 2019
      #updateDisp <- mapply(FUN = randomDispersal, mozziedf$lat[toMigrate],mozziedf$long[toMigrate],lambda) #CHECK this works with length(toMigrate) > 1
      #updateDisp <- do.call(rbind,updateDisp)


      #----JUST FOR ANZIAM 2019: uniform random dispersal (REMOVE/FIX later)
      updateDisp <- mapply(FUN = randomRANDOMDispersal, mozziedf$lat[toMigrate],mozziedf$long[toMigrate]) #CHECK this works with length(toMigrate) > 1
      updateDisp <- do.call(rbind,updateDisp)


      #Suppressing warnings for this assignment at the moment- this operation coerces a list to a double, going from a precision of 47 dp to 45 dp.
      ##However for lat/long any more than 10 dp is fairly nonsensical so we don't care
      suppressWarnings(mozziedf[toMigrate,"lat" := updateDisp[1,]])
      suppressWarnings(mozziedf[toMigrate, "long" := updateDisp[2,]])
      rm(updateDisp)
    }


    rm(toMigrate)
  ##---End Step 7

    #---Step 8: update the numerical age of each agent
    juvdf$age <- mapply('+',juvdf$age, 1)
    mozziedf$age <- mapply('+',mozziedf$age,1)


    #---End Step 8


  ##-----Step 9: Mosquito releases (currently in prototype phase)
    #CHANGE: just choosing 9 as a random time step, but obviously we want to do this on days there are releases
    #number of mozzies released
    if(t == 3){
      noReleased <- 270
      releasedf <- initialiseRelease(noReleased,pmale,-16.918,145.760)

      #do a dispersal event when you release them? CHECK this is really hacky
      #updateDisp <- mapply(FUN = randomDispersal, releasedf$lat,releasedf$long,lambda) #CHECK this works with length(toMigrate) > 1
      #updateDisp <- do.call(rbind,updateDisp)

      updateDisp <- mapply(FUN = randomRANDOMDispersal, releasedf$lat , releasedf$long) #CHECK this works with length(toMigrate) > 1
      updateDisp <- do.call(rbind,updateDisp)


      releaselat <- unlist(updateDisp[c(TRUE,FALSE)])
      releaselong <- unlist(updateDisp[c(FALSE,TRUE)])
      releasedf$lat <- releaselat
      releasedf$long <-releaselong

      #suppressWarnings(releasedf[toMigrate,"lat" := updateDisp[1,]])
      #suppressWarnings(releasedf[toMigrate, "long" := updateDisp[2,]])


      mozziedf <- rbind(mozziedf,releasedf)
      rm(releasedf)
    }


    if(t == 7){
      noReleased <- 270
      releasedf <- initialiseRelease(noReleased,pmale,-16.922,145.766)

      #do a dispersal event when you release them? CHECK this is really hacky
      #updateDisp <- mapply(FUN = randomDispersal, releasedf$lat,releasedf$long,lambda) #CHECK this works with length(toMigrate) > 1
      #updateDisp <- do.call(rbind,updateDisp)

      updateDisp <- mapply(FUN = randomRANDOMDispersal, releasedf$lat , releasedf$long) #CHECK this works with length(toMigrate) > 1
      updateDisp <- do.call(rbind,updateDisp)


      releaselat <- unlist(updateDisp[c(TRUE,FALSE)])
      releaselong <- unlist(updateDisp[c(FALSE,TRUE)])
      releasedf$lat <- releaselat
      releasedf$long <-releaselong

      #suppressWarnings(releasedf[toMigrate,"lat" := updateDisp[1,]])
      #suppressWarnings(releasedf[toMigrate, "long" := updateDisp[2,]])


      mozziedf <- rbind(mozziedf,releasedf)

      rm(releasedf)
      releasedf <- initialiseRelease(noReleased,pmale,-16.922,145.760)

      #do a dispersal event when you release them? CHECK this is really hacky
      #updateDisp <- mapply(FUN = randomDispersal, releasedf$lat,releasedf$long,lambda) #CHECK this works with length(toMigrate) > 1
      #updateDisp <- do.call(rbind,updateDisp)

      updateDisp <- mapply(FUN = randomRANDOMDispersal, releasedf$lat , releasedf$long) #CHECK this works with length(toMigrate) > 1
      updateDisp <- do.call(rbind,updateDisp)


      releaselat <- unlist(updateDisp[c(TRUE,FALSE)])
      releaselong <- unlist(updateDisp[c(FALSE,TRUE)])
      releasedf$lat <- releaselat
      releasedf$long <-releaselong

      #suppressWarnings(releasedf[toMigrate,"lat" := updateDisp[1,]])
      #suppressWarnings(releasedf[toMigrate, "long" := updateDisp[2,]])


      mozziedf <- rbind(mozziedf,releasedf)
      rm(releasedf)
    }


    if(t == 12){
      noReleased <- 270
      releasedf <- initialiseRelease(noReleased,pmale,-16.922,145.760)

      #do a dispersal event when you release them? CHECK this is really hacky
      #updateDisp <- mapply(FUN = randomDispersal, releasedf$lat,releasedf$long,lambda) #CHECK this works with length(toMigrate) > 1
      #updateDisp <- do.call(rbind,updateDisp)

      updateDisp <- mapply(FUN = randomRANDOMDispersal, releasedf$lat , releasedf$long) #CHECK this works with length(toMigrate) > 1
      updateDisp <- do.call(rbind,updateDisp)


      releaselat <- unlist(updateDisp[c(TRUE,FALSE)])
      releaselong <- unlist(updateDisp[c(FALSE,TRUE)])
      releasedf$lat <- releaselat
      releasedf$long <-releaselong

      #suppressWarnings(releasedf[toMigrate,"lat" := updateDisp[1,]])
      #suppressWarnings(releasedf[toMigrate, "long" := updateDisp[2,]])


      mozziedf <- rbind(mozziedf,releasedf)
      rm(releasedf)
    }
  #---End Step 9

  #---End of time step

    #trying animation:
  # p <- ggplot(mozziedf, aes(as.numeric(mozziedf$lat),as.numeric(mozziedf$long))) +
  #    geom_point(aes(colour = factor(as.numeric(mozziedf$infStatus)))) +
  #    scale_colour_manual(breaks = c("0","1"), values =  c("#F78A17","#4F6D5E")) +

  ##    labs(title = "Timestep: {frame_time}", x = "Longitude", y = "Latitude") + labs(color="Wolbachia status") +
  #    transition_time(t) +
  #    ease_aes('linear') +
  #    transition_states(factor(as.numeric(mozziedf$infStatus)))

    #gganimate(p)


    #Trying animation by way of making lots of plots:

    #p <- ggplot(mozziedf, aes(as.numeric(mozziedf$lat),as.numeric(mozziedf$long)))
    #might need to change breaks to 0,1 and -1 for CI
    #p <- p + geom_point(aes(colour = factor(as.numeric(mozziedf$infStatus))), size = 3,position=position_jitter(h=0.015,w=0.015)) + scale_colour_manual(breaks = c("0","1"), values =  c("#F78A17","#4F6D5E","#F9E0D9")) + labs(x = "Longitude", y = "Latitude") + labs(color="Wolbachia status") + coord_cartesian(xlim=c(-16.94,-16.9),ylim=c(145.725,145.8))
    #plot_list[[t]] <- p
    #lim=c(-16.92474,-16.91092),ylim=c(145.7525,145.7707)
    #file_name <- paste("day_", t, ".tiff", sep="")
    #tiff(file_name)
    #print(plot_list[[t]])
    #dev.off()

    t <- t + 1
  }




#----- plotting stuff for ANZIAM talk
  #celineColours <- c("#4F6D5E","#F9E0D9","#F78A17")
  celineGO <- c("#4F6D5E","#F78A17") #just green and orange
p <- ggplot(mozziedf, aes(as.numeric(mozziedf$lat),as.numeric(mozziedf$long)))
#might need to change breaks to 0,1 and -1 for CI
p + geom_point(aes(colour = factor(as.numeric(mozziedf$infStatus))), size = 2) + scale_colour_manual(breaks = c("0","1","-1"), values =  c("#F78A17","#4F6D5E","#F9E0D9")) + labs(x = "Longitude", y = "Latitude") + labs(color="Wolbachia status")
