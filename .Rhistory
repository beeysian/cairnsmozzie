b = rtruncnorm(1,mean=0.22,sd=0.05,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
alpha_a = 0.1, #adult mortality rate, approx. from literature
alpha_j = 0.2, #juvenile mortality rate: this is made up
p_1 = 1, #Probability of complete maternal transmission (virtually 100% according to Ross '16 & '17)
eta_1 = round(rnorm(1,mean=40,sd=7),0), #no. of offspring produced by Wb non-carrier mothers
eta_2 = 0) #this was changed 8/1/20: Dutra15 and Ant18 imply eta_1 = eta_2
#eta_2 = round(rnorm(1,mean=30,sd=5),0)) #no. of offspring produced by Wb carrier mothers
param$eta_2 <- param$eta_1 # Dutra15 and Ant18 imply eta_1 = eta_2
# End of parameter generation
# Variable initialisation ----
N       <- 1000 #number of adult mosquitoes at time t=0. To be initialised between 4000 to 20000
Njuv    <- 10 #number of juvenile CLUSTERS (not individuals) at time t=0
idStart <- N+1 #ID numbers of initial adults will be 1:N, then we start at N+1 for any new adult mosquito within simulation
noTimeSteps <- 90 #our simulation runs for 90 days
t <- 0 #timestep; starts from 0.
# End variable initialisation
# Calculate temperature and growth charts ----
#Chart of average daily temperatures for each day of the simulation
dailyTemps <- temperature_chart(minTemp, maxTemp, noTimeSteps)
# If we're running microclimates, set them up ----
if(include_microclimates == 1){
print("Simulation includes microclimates")
# Realistic microclimates
EKMChart <- initialise_enzyme_wmicroclim(boundary.bb, dailyTemps, typeTempDevs, noTimeSteps, noLandTypes, gridSize, const)
} else if(include_microclimates == 0){
print("No microclimates in simulation")
EKMChart <- initialize_enzyme(dailyTemps) #chart of daily updates for EKS
}
# End microclimate setup
# End chart calculation
# Set up trap locations and clean trapping data ----
trapClean       <- trap_clean(trappingDat) # Clean trapping data
trapLoc         <- trap_setup(trapClean) # Dataframe of trap locations in lat/long
number_of_traps <- length(trapLoc$V1) # Number of traps in simulation
daily_trapped   <- list() #Placeholder for real trapping output data
# End trapping data setup ----
# Wrangling of release data used in simulation ----
releaseDat   <- release_clean(releaseDat) #Cleaning release data
release.days <- as.data.frame(table(day = releaseDat$Day)) #Grabbing days that releases were made
# End of release data wrangling
# Set up grid- even if no microclimates used ----
grid.df <- make_grid(boundary.bb, gridSize)
# End grid setup
# Model initialisation/construction ----
mozzie.dt <- as.data.table(initialise_adults(N, param$pmale)) #initial adult population
juv.dt    <- as.data.table(initialise_juveniles(Njuv)) #initial juvenile population
graveyard <- initialise_graveyard() # Where entries of dead mosquitoes go.
# End initial model construction
t <- 1
# Step 4: Natural mosquito death (juvenile and adult) ----
##Juvenile natural death: remove 10% of the population
##The subsetting of juvdf$clutchSize is because we don't reduce clutch size of CI-affected eggs:
## they're already dead, but we just want to track how many there are so we leave clutchSize alone
juv.dt$clutchSize[which(juv.dt$pDeath != -1)] <- mapply(FUN = resize_clutch,juv.dt$clutchSize, param$alpha_j)
View(juv.dt)
##Adult death:
##Adults die automatically when they reach age 40
##Vector of mosquitoes that will die of old age
to.old.die <- which(mozzie.dt$age == max_age & mozzie.dt$timeDeath == -1)
mozzie.dt[!sample(.N, round(param$alpha_a*nrow(mozzie.dt)))]
##Adults can also die as per natural death rate
mozzie.dt <- mozzie.dt[!sample(.N, round(param$alpha_a*nrow(mozzie.dt)))]
# Step 5: Mosquito mating ----
#We only need to find mates for:
## Females that don't have mates and haven't laid eggs yet (first gono cycle)
## AND has EKS >= 1 (From Focks)
to.mate <- which((mozzie.dt$gender == 1 & mozzie.dt$mateID == -1 & mozzie.dt$gonoCycle == 0 & mozzie.dt$enzyme >= 1))
if(length(to.mate) != 0){
mozzie.dt$mateID[to.mate] <- mapply(FUN = find_mate, to.mate, param$k)
#for testing: gives the vector of mate IDs for the bachelorette mosquitoes
#try <- mapply(FUN=findMate,toMate,k)
}
rm(to.mate)
# Step 6: Updating Enzyme Kinetic Score for each agent ----
##Update EKS for juvenile agents
juv.enzyme.update <- mapply(FUN = update_enzyme, juv.dt$stage, t)
#This is a super hacky method....
juv.dt$enzyme <- as.numeric(juv.dt$enzyme) + as.numeric(juv.enzyme.update)
##Update EKS for adult agents
##Adult mosquitoes always update with the same EKM formula, hence are always in "stage 4"
mozzie.enzyme.update <- mapply(FUN = update_enzyme,4,t)
mozzie.dt$enzyme <- as.numeric(mozzie.dt$enzyme) + as.numeric(mozzie.enzyme.update)
rm(juv.enzyme.update)
rm(mozzie.enzyme.update)
# Step 7: Mosquito dispersal ----
##Determine which mosquitoes are going to migrate
to.migrate <- which(mozzie.dt$age == 19) #CHANGE
if(length(to.migrate) != 0){
#CHECK this works with length(toMigrate) > 1
update.disp <- mapply(FUN = random_dispersal, mozzie.dt$lat[to.migrate], mozzie.dt$long[to.migrate], param$lambda)
update.disp <- do.call(rbind, update.disp)
#Suppressing warnings for this assignment at the moment:
##this operation coerces a list to a double, going from a precision of 47 dp to 45 dp.
##However for lat/long any value to more than 10 dp is fairly nonsensical (sub milimetre) so we don't care
suppressWarnings(mozzie.dt[to.migrate, "lat" := update.disp[1,]])
suppressWarnings(mozzie.dt[to.migrate, "long" := update.disp[2,]])
rm(update.disp)
}
rm(to.migrate)
# Step 8: Update numerical 'age' of agent ----
juv.dt$age <- mapply('+', juv.dt$age, 1)
mozzie.dt$age <- mapply('+', mozzie.dt$age, 1)
# Update timestep ----
t <- t + 1
to.adult <- which(juv.dt$stage == 3 & juv.dt$enzyme > 0.95)
if((length(to.adult)) != 0){
new.adults.dt <- mapply(FUN=juv_to_adult, to.adult, idStart, param$pmale, param$lambda, SIMPLIFY = FALSE)
new.adults.dt %<>% rbindlist() %>% as.data.table()
mozzie.dt     <<- rbind(mozzie.dt, new.adults.dt)
#delete row(s) of data table corresponding to the clutches that aged into adult mozzies
juv.dt        <<- juv.dt[-to.adult]
rm(new.adults.dt)
}
# Step 1.5: any juveniles moving to the next development stage? ----
# If enzyme > 0.95, move on to the next development stage and reset enzyme score
if(length(which(juv.dt$enzyme > 0.95)) > 0){
#which(juvdf$enzyme > 0.95)
juv.dt[which(juv.dt$enzyme > 0.95)]$stage  <- juv.dt[which(juv.dt$enzyme > 0.95)]$stage + 1
#this gives HELLA warnings- try mapply or lapply or something?
juv.dt[which(juv.dt$enzyme > 0.95)]$enzyme <- 0
#juvdf[which(juvdf$enzyme > 0.95)]$stage <- lapply(juvdf[which(juvdf$enzyme > 0.95)]$stage, function(x) x <- juvdf$enzyme[x] <- 0)
}
# End Step 1.5
rm(to.adult)
#If adult population size now exceeds max_pop_size, kill the simulation
if(nrow(mozzie.dt) > max_pop_size){
print("Maximum population size exceeded")
break
}
# End Step 1
# Step 2: Egg laying ----
#Determine which mothers will lay their eggs today
#Conditions to be satisfied for a mother to lay a clutch of eggs:
## 1) Has a mate
## 2) Enzyme Kinetic Score > 1 (should mean that mosquito has a mate)
## 3) First egg laying event is at EKS > 1, second at 1.58,
##    third at 2.16, etc. for multiples of 0.58 (from Focks et al '93)
to.lay <- which(mozzie.dt$gender == 1 & mozzie.dt$mateID != -1 & ((mozzie.dt$enzyme >= 1 & mozzie.dt$gonoCycle == 0) | (mozzie.dt$enzyme >= 1.58 & mozzie.dt$gonoCycle == 1) | (mozzie.dt$enzyme >= 2.16 & mozzie.dt$gonoCycle == 2)))
if(length(to.lay) != 0){
new.eggs.dt <- initialise_eggs(to.lay)
juv.dt      <- rbind(juv.dt,new.eggs.dt)
rm(new.eggs.dt)
}
rm(to.lay) #Remove to.lay
# End Step 2
# Step 3: Do we have mosquitoes being trapped (and killed?) ----
to.trap <- list()
for(i in 1:number_of_traps){
temptrap <- find_trapped(trapLoc$V1[i], trapLoc$V2[i], param$phi, mozzie.dt)
if(length(temptrap)!= 0 && temptrap[1] != -1){
#if this is slow, work out how to use rbindlist
#to.trap <- rbind(to.trap, temptrap)
if(i == 1){
to.trap <- temptrap
mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
}else{to.trap <- append(to.trap, temptrap)
mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
}
}
rm(temptrap)
# Updating the entries of mozzies that have been trapped
mozzie.dt[mozzie.dt$ID %in% to.trap,]$typeDeath <- 1 # Type of death is trapped death
mozzie.dt[mozzie.dt$ID %in% to.trap,]$timeDeath <- t # They died today
to.trap   <- unique(to.trap) #in case there are duplicates
l         <- list(graveyard, mozzie.dt[mozzie.dt$ID %in% to.trap,])
graveyard <- rbindlist(l) # Trapped mozzies go in the graveyard!
#THE BELOW LINE NEEDS FIXING/TO WORK
mozzie.dt <- mozzie.dt[-(mozzie.dt$ID %in% to.trap)]# Delete entries of mozzies who have been trapped and killed
}
#For fun: plotting traps and agent locations
#bdary <- read.table("inst/exdata/testboundary.txt", sep=" ", header=TRUE) #read in data
#trapp <- ggplot(trapLoc, aes(x=V1, y=V2)) + geom_point()
#trapp + geom_point(data=mozzie.dt, aes(x=mozzie.dt$lat, y=mozzie.dt$long, color="red")) +
#geom_path(data = boundary.bb, aes(x=boundary.bb$lat, y=boundary.bb$long, color="green")) +
#geom_path(data = boundaryDat, aes(x = boundaryDat$Lat, y=boundaryDat$Long, color="blue"))
# Now that we have determined which adults get trapped (if any), we need to update mozzie.dt to reflect this
# End Step 3
# Step 4: Natural mosquito death (juvenile and adult) ----
##Juvenile natural death: remove 10% of the population
##The subsetting of juvdf$clutchSize is because we don't reduce clutch size of CI-affected eggs:
## they're already dead, but we just want to track how many there are so we leave clutchSize alone
juv.dt$clutchSize[which(juv.dt$pDeath != -1)] <- mapply(FUN = resize_clutch,juv.dt$clutchSize, param$alpha_j)
##Adult death:
##Adults die automatically when they reach age 40
##Vector of mosquitoes that will die of old age
to.old.die <- which(mozzie.dt$age == max_age & mozzie.dt$timeDeath == -1)
if((length(to.old.die)) != 0){
#Track day that they died (timeDeath) and set typeDeath = 0 to denote natural (not trapped) death
mozzie.dt$typeDeath[to.old.die] <- 0
mozzie.dt$timeDeath[to.old.die] <- t
mozzie.dt <- mozzie.dt[!to.old.die,]
}
rm(to.old.die)
##Adults can also die as per natural death rate
mozzie.dt <- mozzie.dt[!sample(.N, round(param$alpha_a*nrow(mozzie.dt)))]
#ADD THE FOLLOWING TWO LINES BACK FOR MAIN SIM
mozziedf$typeDeath[toNatDie] <- 0
mozziedf$timeDeath[toNatDie] <- t
# Step 5: Mosquito mating ----
#We only need to find mates for:
## Females that don't have mates and haven't laid eggs yet (first gono cycle)
## AND has EKS >= 1 (From Focks)
to.mate <- which((mozzie.dt$gender == 1 & mozzie.dt$mateID == -1 & mozzie.dt$gonoCycle == 0 & mozzie.dt$enzyme >= 1))
if(length(to.mate) != 0){
mozzie.dt$mateID[to.mate] <- mapply(FUN = find_mate, to.mate, param$k)
#for testing: gives the vector of mate IDs for the bachelorette mosquitoes
#try <- mapply(FUN=findMate,toMate,k)
}
rm(to.mate)
##For male agents, gonoCycle has a different purpose:
#Resetting gonoCycle for the next day for male agents since gonoCycle tracks
mozzie.dt$gonoCycle[which(mozzie.dt$gender == 0)] <- 0
# End Step 5
# Step 6: Updating Enzyme Kinetic Score for each agent ----
##Update EKS for juvenile agents
juv.enzyme.update <- mapply(FUN = update_enzyme, juv.dt$stage, t)
#This is a super hacky method....
juv.dt$enzyme <- as.numeric(juv.dt$enzyme) + as.numeric(juv.enzyme.update)
##Update EKS for adult agents
##Adult mosquitoes always update with the same EKM formula, hence are always in "stage 4"
mozzie.enzyme.update <- mapply(FUN = update_enzyme,4,t)
mozzie.dt$enzyme <- as.numeric(mozzie.dt$enzyme) + as.numeric(mozzie.enzyme.update)
rm(juv.enzyme.update)
rm(mozzie.enzyme.update)
# End Step 6
# Step 7: Mosquito dispersal ----
##Determine which mosquitoes are going to migrate
to.migrate <- which(mozzie.dt$age == 19) #CHANGE
if(length(to.migrate) != 0){
#CHECK this works with length(toMigrate) > 1
update.disp <- mapply(FUN = random_dispersal, mozzie.dt$lat[to.migrate], mozzie.dt$long[to.migrate], param$lambda)
update.disp <- do.call(rbind, update.disp)
#Suppressing warnings for this assignment at the moment:
##this operation coerces a list to a double, going from a precision of 47 dp to 45 dp.
##However for lat/long any value to more than 10 dp is fairly nonsensical (sub milimetre) so we don't care
suppressWarnings(mozzie.dt[to.migrate, "lat" := update.disp[1,]])
suppressWarnings(mozzie.dt[to.migrate, "long" := update.disp[2,]])
rm(update.disp)
}
rm(to.migrate)
# End Step 7
# Step 8: Update numerical 'age' of agent ----
juv.dt$age <- mapply('+', juv.dt$age, 1)
mozzie.dt$age <- mapply('+', mozzie.dt$age, 1)
View(mozzie.dt)
boundaryDat <- read.table("inst/exdata/New_pp_Bound.txt", header=TRUE) #Boundary data for the boundary of the area used in trial (given as a set of lat/long points)
boundary.bb <- read.table("inst/exdata/testboundary.txt", header=TRUE) # Bounding box of boundary, used for microclimates
minTemp     <- read.table("inst/exdata/cairnsAero_minTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
maxTemp     <- read.table("inst/exdata/cairnsAero_maxTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
const       <- read.table("inst/exdata/constants.txt", header=TRUE) #constants used for EKM calculations
releaseDat  <- read.table("inst/exdata/PP_release.txt", header=TRUE) #Data regarding mosquito releases
trappingDat <- read.table("inst/exdata/PP_trapping_data.txt", sep=",", header=TRUE) #Trapping data for mosquitoes
# End reading in files
# Set global constants ----
max_age         <- 30 #mozzies who reach this age automatically die naturally
max_juv_age     <- 14 #juveniles who reach this age automatically become adults
max_pop_size    <- 100000 #if adult population exceeds this size, terminate simulation
init_prop_inf   <- 0 #initial proportion of wild mozzies carrying Wolbachia- we expect this to be 0
max_daily_mates <- 2 #maximum number of mating events a MALE mosquito can have in a day (from literature)
include_microclimates <- 0 #Set to 1 to include microclimates effect, 0 to not include
gridSize        <- 0.00025 # Size of grid spacing for microclimates
noLandTypes     <- 7 # Number of land types considered in microclimate analysis
typeTempDevs    <- c(1,-2,-1,10,5,-3, 2) # Temperature deviates for each land type- FIX (should be read in)
# End global constants
param <- data.frame(lambda = rgamma(1,3,22),
pmale = 0.45, #proportion of male mosquitoes in wild population: FIXED
k = rgamma(1,shape=1,scale=1/35),
phi = runif(1,0.00001,0.001), #hyperparameter for probability that mozzies are trapped by any given trap
a = rtruncnorm(1,mean=0.02,sd=0.01,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
b = rtruncnorm(1,mean=0.22,sd=0.05,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
alpha_a = 0.1, #adult mortality rate, approx. from literature
alpha_j = 0.2, #juvenile mortality rate: this is made up
p_1 = 1, #Probability of complete maternal transmission (virtually 100% according to Ross '16 & '17)
eta_1 = round(rnorm(1,mean=40,sd=7),0), #no. of offspring produced by Wb non-carrier mothers
eta_2 = 0) #this was changed 8/1/20: Dutra15 and Ant18 imply eta_1 = eta_2
#eta_2 = round(rnorm(1,mean=30,sd=5),0)) #no. of offspring produced by Wb carrier mothers
param$eta_2 <- param$eta_1 # Dutra15 and Ant18 imply eta_1 = eta_2
# End of parameter generation
N       <- 1000 #number of adult mosquitoes at time t=0. To be initialised between 4000 to 20000
Njuv    <- 10 #number of juvenile CLUSTERS (not individuals) at time t=0
idStart <- N+1 #ID numbers of initial adults will be 1:N, then we start at N+1 for any new adult mosquito within simulation
noTimeSteps <- 90 #our simulation runs for 90 days
t <- 0 #timestep; starts from 0.
# End
# Calculate temperature and growth charts ----
#Chart of average daily temperatures for each day of the simulation
dailyTemps <- temperature_chart(minTemp, maxTemp, noTimeSteps)
# If we're running microclimates, set them up ----
if(include_microclimates == 1){
print("Simulation includes microclimates")
# Realistic microclimates
EKMChart <- initialise_enzyme_wmicroclim(boundary.bb, dailyTemps, typeTempDevs, noTimeSteps, noLandTypes, gridSize, const)
} else if(include_microclimates == 0){
print("No microclimates in simulation")
EKMChart <- initialize_enzyme(dailyTemps) #chart of daily updates for EKS
}
# Set up trap locations and clean trapping data ----
trapClean       <- trap_clean(trappingDat) # Clean trapping data
trapLoc         <- trap_setup(trapClean) # Dataframe of trap locations in lat/long
number_of_traps <- length(trapLoc$V1) # Number of traps in simulation
daily_trapped   <- list() #Placeholder for real trapping output data
# Wrangling of release data used in simulation ----
releaseDat   <- release_clean(releaseDat) #Cleaning release data
release.days <- as.data.frame(table(day = releaseDat$Day)) #Grabbing days that releases were made
# Set up grid- even if no microclimates used ----
grid.df <- make_grid(boundary.bb, gridSize)
# Model initialisation/construction ----
mozzie.dt <- as.data.table(initialise_adults(N, param$pmale)) #initial adult population
juv.dt    <- as.data.table(initialise_juveniles(Njuv)) #initial juvenile population
graveyard <- initialise_graveyard() # Where entries of dead mosquitoes go.
t <- 1
# Step 1: Juvenile emergence -----
to.adult <- which(juv.dt$stage == 3 & juv.dt$enzyme > 0.95)
if((length(to.adult)) != 0){
new.adults.dt <- mapply(FUN=juv_to_adult, to.adult, idStart, param$pmale, param$lambda, SIMPLIFY = FALSE)
new.adults.dt %<>% rbindlist() %>% as.data.table()
mozzie.dt     <<- rbind(mozzie.dt, new.adults.dt)
#delete row(s) of data table corresponding to the clutches that aged into adult mozzies
juv.dt        <<- juv.dt[-to.adult]
rm(new.adults.dt)
}
# Step 1.5: any juveniles moving to the next development stage? ----
# If enzyme > 0.95, move on to the next development stage and reset enzyme score
if(length(which(juv.dt$enzyme > 0.95)) > 0){
#which(juvdf$enzyme > 0.95)
juv.dt[which(juv.dt$enzyme > 0.95)]$stage  <- juv.dt[which(juv.dt$enzyme > 0.95)]$stage + 1
#this gives HELLA warnings- try mapply or lapply or something?
juv.dt[which(juv.dt$enzyme > 0.95)]$enzyme <- 0
#juvdf[which(juvdf$enzyme > 0.95)]$stage <- lapply(juvdf[which(juvdf$enzyme > 0.95)]$stage, function(x) x <- juvdf$enzyme[x] <- 0)
}
rm(to.adult)
to.lay <- which(mozzie.dt$gender == 1 & mozzie.dt$mateID != -1 & ((mozzie.dt$enzyme >= 1 & mozzie.dt$gonoCycle == 0) | (mozzie.dt$enzyme >= 1.58 & mozzie.dt$gonoCycle == 1) | (mozzie.dt$enzyme >= 2.16 & mozzie.dt$gonoCycle == 2)))
if(length(to.lay) != 0){
new.eggs.dt <- initialise_eggs(to.lay)
juv.dt      <- rbind(juv.dt,new.eggs.dt)
rm(new.eggs.dt)
}
# Step 3: Do we have mosquitoes being trapped (and killed?) ----
to.trap <- list()
for(i in 1:number_of_traps){
temptrap <- find_trapped(trapLoc$V1[i], trapLoc$V2[i], param$phi, mozzie.dt)
if(length(temptrap)!= 0 && temptrap[1] != -1){
#if this is slow, work out how to use rbindlist
#to.trap <- rbind(to.trap, temptrap)
if(i == 1){
to.trap <- temptrap
mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
}else{to.trap <- append(to.trap, temptrap)
mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
}
}
rm(temptrap)
# Updating the entries of mozzies that have been trapped
mozzie.dt[mozzie.dt$ID %in% to.trap,]$typeDeath <- 1 # Type of death is trapped death
mozzie.dt[mozzie.dt$ID %in% to.trap,]$timeDeath <- t # They died today
to.trap   <- unique(to.trap) #in case there are duplicates
l         <- list(graveyard, mozzie.dt[mozzie.dt$ID %in% to.trap,])
graveyard <- rbindlist(l) # Trapped mozzies go in the graveyard!
#THE BELOW LINE NEEDS FIXING/TO WORK
mozzie.dt <- mozzie.dt[-(mozzie.dt$ID %in% to.trap)]# Delete entries of mozzies who have been trapped and killed
}
View(graveyard)
test <- unique(graveyard)
test <- graveyard[1:54,]
View(test)
# Step 4: Natural mosquito death (juvenile and adult) ----
##Juvenile natural death: remove 10% of the population
##The subsetting of juvdf$clutchSize is because we don't reduce clutch size of CI-affected eggs:
## they're already dead, but we just want to track how many there are so we leave clutchSize alone
juv.dt$clutchSize[which(juv.dt$pDeath != -1)] <- mapply(FUN = resize_clutch,juv.dt$clutchSize, param$alpha_j)
##Adult death:
##Adults die automatically when they reach age 40
##Vector of mosquitoes that will die of old age
to.old.die <- which(mozzie.dt$age == max_age & mozzie.dt$timeDeath == -1)
if((length(to.old.die)) != 0){
#Track day that they died (timeDeath) and set typeDeath = 0 to denote natural (not trapped) death
mozzie.dt$typeDeath[to.old.die] <- 0
mozzie.dt$timeDeath[to.old.die] <- t
mozzie.dt <- mozzie.dt[!to.old.die,]
}
rm(to.old.die)
# Step 5: Mosquito mating ----
#We only need to find mates for:
## Females that don't have mates and haven't laid eggs yet (first gono cycle)
## AND has EKS >= 1 (From Focks)
to.mate <- which((mozzie.dt$gender == 1 & mozzie.dt$mateID == -1 & mozzie.dt$gonoCycle == 0 & mozzie.dt$enzyme >= 1))
if(length(to.mate) != 0){
mozzie.dt$mateID[to.mate] <- mapply(FUN = find_mate, to.mate, param$k)
#for testing: gives the vector of mate IDs for the bachelorette mosquitoes
#try <- mapply(FUN=findMate,toMate,k)
}
rm(to.mate)
##For male agents, gonoCycle has a different purpose:
#Resetting gonoCycle for the next day for male agents since gonoCycle tracks
mozzie.dt$gonoCycle[which(mozzie.dt$gender == 0)] <- 0
# Step 6: Updating Enzyme Kinetic Score for each agent ----
##Update EKS for juvenile agents
juv.enzyme.update <- mapply(FUN = update_enzyme, juv.dt$stage, t)
#This is a super hacky method....
juv.dt$enzyme <- as.numeric(juv.dt$enzyme) + as.numeric(juv.enzyme.update)
##Update EKS for adult agents
##Adult mosquitoes always update with the same EKM formula, hence are always in "stage 4"
mozzie.enzyme.update <- mapply(FUN = update_enzyme,4,t)
mozzie.dt$enzyme <- as.numeric(mozzie.dt$enzyme) + as.numeric(mozzie.enzyme.update)
rm(juv.enzyme.update)
rm(mozzie.enzyme.update)
# Step 7: Mosquito dispersal ----
##Determine which mosquitoes are going to migrate
to.migrate <- which(mozzie.dt$age == 19) #CHANGE
if(length(to.migrate) != 0){
#CHECK this works with length(toMigrate) > 1
update.disp <- mapply(FUN = random_dispersal, mozzie.dt$lat[to.migrate], mozzie.dt$long[to.migrate], param$lambda)
update.disp <- do.call(rbind, update.disp)
#Suppressing warnings for this assignment at the moment:
##this operation coerces a list to a double, going from a precision of 47 dp to 45 dp.
##However for lat/long any value to more than 10 dp is fairly nonsensical (sub milimetre) so we don't care
suppressWarnings(mozzie.dt[to.migrate, "lat" := update.disp[1,]])
suppressWarnings(mozzie.dt[to.migrate, "long" := update.disp[2,]])
rm(update.disp)
}
rm(to.migrate)
# Step 8: Update numerical 'age' of agent ----
juv.dt$age <- mapply('+', juv.dt$age, 1)
mozzie.dt$age <- mapply('+', mozzie.dt$age, 1)
# Update timestep ----
t <- t + 1
# Step 1: Juvenile emergence -----
to.adult <- which(juv.dt$stage == 3 & juv.dt$enzyme > 0.95)
if((length(to.adult)) != 0){
new.adults.dt <- mapply(FUN=juv_to_adult, to.adult, idStart, param$pmale, param$lambda, SIMPLIFY = FALSE)
new.adults.dt %<>% rbindlist() %>% as.data.table()
mozzie.dt     <<- rbind(mozzie.dt, new.adults.dt)
#delete row(s) of data table corresponding to the clutches that aged into adult mozzies
juv.dt        <<- juv.dt[-to.adult]
rm(new.adults.dt)
}
View(mozzie.dt)
# Package importing ----
library(dplyr)
library(rbenchmark)
library(progress) #progress bar for for loop
library(magrittr)
library(data.table)
library(sp) #for the boundary check when dealing with mozzie dispersal
library(truncnorm) #for parameter sampling from the truncated normal (needed for ABC step)
library(flexsurv) #used for the Gompertz distribution for age distribution
library(geosphere) #used for distance and dispersal calculations
library(MCMCpack) #used for dirichlet distribution samples
library(lattice) #used for dividing simulation area into grid for temperature deviates
library(mozzie) #for all the functions!
# Read in data files ----
boundaryDat <- read.table("inst/exdata/New_pp_Bound.txt", header=TRUE) #Boundary data for the boundary of the area used in trial (given as a set of lat/long points)
boundary.bb <- read.table("inst/exdata/testboundary.txt", header=TRUE) # Bounding box of boundary, used for microclimates
minTemp     <- read.table("inst/exdata/cairnsAero_minTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
maxTemp     <- read.table("inst/exdata/cairnsAero_maxTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
const       <- read.table("inst/exdata/constants.txt", header=TRUE) #constants used for EKM calculations
releaseDat  <- read.table("inst/exdata/PP_release.txt", header=TRUE) #Data regarding mosquito releases
trappingDat <- read.table("inst/exdata/PP_trapping_data.txt", sep=",", header=TRUE) #Trapping data for mosquitoes
# End reading in files
# Set global constants ----
max_age         <- 30 #mozzies who reach this age automatically die naturally
max_juv_age     <- 14 #juveniles who reach this age automatically become adults
max_pop_size    <- 100000 #if adult population exceeds this size, terminate simulation
init_prop_inf   <- 0 #initial proportion of wild mozzies carrying Wolbachia- we expect this to be 0
max_daily_mates <- 2 #maximum number of mating events a MALE mosquito can have in a day (from literature)
include_microclimates <- 0 #Set to 1 to include microclimates effect, 0 to not include
gridSize        <- 0.00025 # Size of grid spacing for microclimates
noLandTypes     <- 7 # Number of land types considered in microclimate analysis
typeTempDevs    <- c(1,-2,-1,10,5,-3, 2) # Temperature deviates for each land type- FIX (should be read in)
# End global constants
# Parameter generation for RABC ----
param <- data.frame(lambda = rgamma(1,3,22),
pmale = 0.45, #proportion of male mosquitoes in wild population: FIXED
k = rgamma(1,shape=1,scale=1/35),
phi = runif(1,0.00001,0.001), #hyperparameter for probability that mozzies are trapped by any given trap
a = rtruncnorm(1,mean=0.02,sd=0.01,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
b = rtruncnorm(1,mean=0.22,sd=0.05,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
alpha_a = 0.1, #adult mortality rate, approx. from literature
alpha_j = 0.2, #juvenile mortality rate: this is made up
p_1 = 1, #Probability of complete maternal transmission (virtually 100% according to Ross '16 & '17)
eta_1 = round(rnorm(1,mean=40,sd=7),0), #no. of offspring produced by Wb non-carrier mothers
eta_2 = 0) #this was changed 8/1/20: Dutra15 and Ant18 imply eta_1 = eta_2
#eta_2 = round(rnorm(1,mean=30,sd=5),0)) #no. of offspring produced by Wb carrier mothers
param$eta_2 <- param$eta_1 # Dutra15 and Ant18 imply eta_1 = eta_2
# End of parameter generation
# Variable initialisation ----
N       <- 1000 #number of adult mosquitoes at time t=0. To be initialised between 4000 to 20000
Njuv    <- 10 #number of juvenile CLUSTERS (not individuals) at time t=0
idStart <- N+1 #ID numbers of initial adults will be 1:N, then we start at N+1 for any new adult mosquito within simulation
noTimeSteps <- 90 #our simulation runs for 90 days
t <- 0 #timestep; starts from 0.
# End variable initialisation
# Calculate temperature and growth charts ----
#Chart of average daily temperatures for each day of the simulation
dailyTemps <- temperature_chart(minTemp, maxTemp, noTimeSteps)
# If we're running microclimates, set them up ----
if(include_microclimates == 1){
print("Simulation includes microclimates")
# Realistic microclimates
EKMChart <- initialise_enzyme_wmicroclim(boundary.bb, dailyTemps, typeTempDevs, noTimeSteps, noLandTypes, gridSize, const)
} else if(include_microclimates == 0){
print("No microclimates in simulation")
EKMChart <- initialize_enzyme(dailyTemps) #chart of daily updates for EKS
}
# Set up trap locations and clean trapping data ----
trapClean       <- trap_clean(trappingDat) # Clean trapping data
trapLoc         <- trap_setup(trapClean) # Dataframe of trap locations in lat/long
number_of_traps <- length(trapLoc$V1) # Number of traps in simulation
daily_trapped   <- list() #Placeholder for real trapping output data
# Wrangling of release data used in simulation ----
releaseDat   <- release_clean(releaseDat) #Cleaning release data
release.days <- as.data.frame(table(day = releaseDat$Day)) #Grabbing days that releases were made
