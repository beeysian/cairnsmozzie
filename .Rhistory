# Temperature at a particular land type = average daily temperature + its associated temperature deviate
landTypeTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
kelvinTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
for(i in 1:noLandTypes){
landTypeTemps[[i]] <- type_tempdevs[i] + dailyTemps
}
# Convert each temperature from Celsius to Kelvin
for(i in 1:noLandTypes){
kelvinTemps[[i]] <- type_tempdevs[i] + dailyTemps + const$KELV_CONV
}
# Converting kelvinTemps to a df for easy calculation
temp.df <- data.frame(matrix(unlist(kelvinTemps), nrow=length(kelvinTemps), byrow=T))
# ---- Calculating growth charts for each life stage
EKM_egg    <- 24*((const$RHO_E*(temp.df/298)*exp((const$HA_E/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_E/const$R)*(((1/const$THALF_E)-(1/temp.df))))))
EKM_larval <- 24*((const$RHO_L*(temp.df/298)*exp((const$HA_L/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_L/const$R)*(((1/const$THALF_L)-(1/temp.df))))))
EKM_pupal  <- 24*((const$RHO_P*(temp.df/298)*exp((const$HA_P/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_P/const$R)*(((1/const$THALF_P)-(1/temp.df))))))
EKM_gono   <- 24*((const$RHO_G*(temp.df/298)*exp((const$HA_G/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_G/const$R)*(((1/const$THALF_G)-(1/temp.df))))))
# To use this list, indexing works like: EKM_chart[[stage]][land_type, ][day]
EKM_chart  <- list(EKM_egg, EKM_larval, EKM_pupal, EKM_gono)
celineColours <- c("#4F6D5E","#F9E0D9","#F78A17")
ggtemp <- ggplot(data = tempdata, aes(x = Longitude, y = Latitude, fill = TemperatureDeviate)) +  geom_raster() + ggtitle("Example of temperature deviate structure") + theme(plot.title = element_text(hjust = 0.5)) +
scale_fill_gradientn(colours = celineColours) +
labs( fill = "Temp. deviate \n(Celsius)") +
theme(axis.text.x = element_blank(), axis.text.y = element_blank())#holy shit this actually works
ggtemp
greenery.bdary <- read.table("greenery_bdary.txt", header=TRUE) #Bounding box of greenery area
martyn.bdary <- read.table("martyn_park_bdary.txt", header=TRUE) #Martyn sports park
tc.bdary <- read.table("martin_tennis_court.txt", sep=",", header=TRUE) #Tennis court next to Martyn sports park
greenery.matchedIDs <- bb_to_matchedIDs(greenery.bdary, gridSize, grid)
martyn.matchedIDs <- bb_to_matchedIDs(martyn.bdary, gridSize, grid)
tc.matchedIDs <- bb_to_matchedIDs(tc.bdary, gridSize, grid)
tempdata$TemperatureDeviate <- 0
tempdata$LandType <- 1
# ---- Set the different land types. There should be noLandTypes of land types
tempdata$LandType[unlist(greenery.matchedIDs)] <- 2
tempdata$LandType[unlist(martyn.matchedIDs)] <- 3
tempdata$LandType[unlist(tc.matchedIDs)] <- 4
#tempdata$LandType[unlist(severin.matchedIDs)] <- 5
#tempdata$LandType[unlist(roads.matchedIDs)] <- 5
tempdata$LandType[unlist(houses.matchedIDs)] <- 6
tempdata$LandType[unlist(osmroads.matchedIDs)] <- 3 #test 11/02/20 osm roads data
tempdata$LandType[unlist(river.matchedIDs)] <- 4 #test 11/02/20 osm river data
tempdata$LandType[unlist(ogreen.matchedIDs)] <- 2 #test 11/02/20 osm river data
tempdata$LandType[unlist(oconc.matchedIDs)] <- 4 #test 11/02/20 osm river data
tempdata$LandType[unlist(trees.matchedIDs)] <- 5 #test 11/02/20 osm river data
# ---- Set the temperature deviates
for (i in 1:noLandTypes){
tempdata$TemperatureDeviate[which(tempdata$LandType == i)] <- type_tempdevs[i]
}
# Apply temperature deviates to daily temperatures for each land type
# Temperature at a particular land type = average daily temperature + its associated temperature deviate
landTypeTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
kelvinTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
for(i in 1:noLandTypes){
landTypeTemps[[i]] <- type_tempdevs[i] + dailyTemps
}
# Convert each temperature from Celsius to Kelvin
for(i in 1:noLandTypes){
kelvinTemps[[i]] <- type_tempdevs[i] + dailyTemps + const$KELV_CONV
}
# Converting kelvinTemps to a df for easy calculation
temp.df <- data.frame(matrix(unlist(kelvinTemps), nrow=length(kelvinTemps), byrow=T))
# ---- Calculating growth charts for each life stage
EKM_egg    <- 24*((const$RHO_E*(temp.df/298)*exp((const$HA_E/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_E/const$R)*(((1/const$THALF_E)-(1/temp.df))))))
EKM_larval <- 24*((const$RHO_L*(temp.df/298)*exp((const$HA_L/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_L/const$R)*(((1/const$THALF_L)-(1/temp.df))))))
EKM_pupal  <- 24*((const$RHO_P*(temp.df/298)*exp((const$HA_P/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_P/const$R)*(((1/const$THALF_P)-(1/temp.df))))))
EKM_gono   <- 24*((const$RHO_G*(temp.df/298)*exp((const$HA_G/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_G/const$R)*(((1/const$THALF_G)-(1/temp.df))))))
# To use this list, indexing works like: EKM_chart[[stage]][land_type, ][day]
EKM_chart  <- list(EKM_egg, EKM_larval, EKM_pupal, EKM_gono)
ggtemp <- ggplot(data = tempdata, aes(x = Longitude, y = Latitude, fill = TemperatureDeviate)) +  geom_raster() + ggtitle("Example of temperature deviate structure") + theme(plot.title = element_text(hjust = 0.5)) +
scale_fill_gradientn(colours = celineColours) +
labs( fill = "Temp. deviate \n(Celsius)") +
theme(axis.text.x = element_blank(), axis.text.y = element_blank())#holy shit this actually works
ggtemp
ggtemp <- ggplot(data = tempdata, aes(x = Longitude, y = Latitude, fill = TemperatureDeviate)) +  geom_raster() + ggtitle("Example of temperature deviate structure") + theme(plot.title = element_text(hjust = 0.5)) +
labs( fill = "Temp. deviate \n(Celsius)") +
theme(axis.text.x = element_blank(), axis.text.y = element_blank())#holy shit this actually works
ggtemp
ggtemp <- ggplot(data = tempdata, aes(x = Longitude, y = Latitude, fill = TemperatureDeviate)) +  geom_raster() + ggtitle("Example of temperature deviate structure") + theme(plot.title = element_text(hjust = 0.5)) +
scale_fill_gradientn(colours = celineColours) +
labs( fill = "Temp. deviate \n(Celsius)") +
theme(axis.text.x = element_blank(), axis.text.y = element_blank())#holy shit this actually works
ggtemp
# Created SMB 9/1/20
# Edited SMB 11/02/20
# The purpose of this script is to:
# 1) Consolidate the work I've already done
# 2) Tighten everything up since the other scripts have useless/antiquated code
# 3) See if there's anything I can do to clean the code up and make it less repetitve
# 4) Construct the EKM lookup table
# The EKM lookup table for microclimates is going to be deterministic with nested tables.
# The order will be: [stage][land type][day]
# So when we update the EKS for each agent, we add the value that is at dt[stage][land type][day]
# Eg: for an egg that is in land type 1 at time step t=2, we add the value at dt[0][1][2] to the agents' EKS
# Land type 0 is for NO temperature deviate effects; this is so we can turn temperature effects off.
# Grid spaces are 25m^2, if you ever see the number 0.00025 this is what it is referring to.
library(ggplot2)
library(data.table)
library(sp)
library(XML)
#' Applies a given temperature deviate to a list of daily temperatures.
#' This function is not used anymore.
#'
#' @param fake_BOMdata A test set of temperatures.
#' @param noDays Number of days in the simulation.
#' @param tempdata Dataframe which includes the temp. deviate for each grid position
#' @return A dataframe of each grid position, its temperature deviate, and localised temperatures in that grid space over time.
apply_tempdev <- function(fake_BOMdata, noDays, tempdata){
for(i in 1:noDays){
tempdata[, 3 + i] <- fake_BOMdata[i] + tempdata$TemperatureDeviate
}
return(tempdata)
}
# this is me sketching something for a full chart ----
#this function is not used anymore
apply_tempdev_chart <- function(fake_BOMdata, noDays, tempdata, stage){
for(i in 1:noDays){
tempdata[, 3 + i] <- fake_BOMdata[i] + tempdata$TemperatureDeviate
}
return(tempdata)
}
#' Converts a polygon boundary into a grid mesh, but in dataframe form
#'
#' @param bdary List of points along the boundary of the simulation area (in lat/long)
#' @param gridSize Grid size. Assumes square grid. In decimal form (eg 0.00025 = 25m^2 grid)
#' @return A dataframe of lat/long coordinates representing the region described by bdary
#'         with space sizes gridSize.
make_grid <- function(bdary, gridSize){
latval <- seq(min(bdary$lat), max(bdary$lat), gridSize)
longval <- seq(min(bdary$long), max(bdary$long), gridSize)
mesh <- expand.grid(latval,longval) #turns list of lat and long into grid
points <- point.in.polygon(mesh$Var1, mesh$Var2, bdary$lat, bdary$long) #identifies grid points that lie within our bounday: NB does not include those on the boundary
grid <- cbind(mesh$Var1[which(points==1)],mesh$Var2[which(points==1)]) #puts these grid spaces into a df
grid <- as.data.frame(grid)
return(grid)
}
#' Determines the grid ID number for each grid space within a bounding box.
#' Useful for, eg, large areas of greenery that we can easily draw a boundary
#'    around, instead of grabbing the lat/long of every point within the region.
#' Returns a dataframe of grid ID numbers that will be associated with that land type.
#'
#' @param bb Bounding box of region, in lat/long
#' @param gridSize Grid size. Assumes square grid. In decimal form (eg 0.00025 = 25m^2 grid)
#' @param grid Dataframe of area grid, as per what's created in make_grid
#' @return A dataframe of grid IDs associated with that land type.
bb_to_matchedIDs <- function(bb, gridSize, grid){
# Passing "grid" might be slow, but let's just do it for now so I can get this code done
mesh <- expand.grid(seq(min(bb$lat), max(bb$lat), gridSize), seq(min(bb$long), max(bb$long), gridSize))
points <- point.in.polygon(mesh$Var1, mesh$Var2, bb$lat, bb$long) #identifies grid points that lie within our bounday: NB does not include those on the boundary
bb.grid <- cbind(mesh$Var1[which(points > 0)], mesh$Var2[which(points > 0)]) #puts these grid spaces into a df
bb.grid <- unique(as.data.frame(bb.grid)) # Get rid of duplicates
matched.IDs <- lapply(1:nrow(bb.grid), function(x){assign_grid(bb.grid[x, ], grid)}) #the 'grid' is our simulation region 'grid'
grid.pos <- unlist(matched.IDs)
matched.IDs <- as.data.frame(grid.pos)
return(matched.IDs)
}
#' Determines the grid ID number corresponding to each lat/long point in the input.
#' Returns a dataframe of grid ID numbers that will be associated with that land type.
#'
#' @param points Lat/long points to be matched to a grid ID.
#' @param grid Dataframe of area grid, as per what's created in make_grid
#' @return A dataframe of grid IDs associated with that land type.
points_to_matchedIDs <- function(points, grid){
IDs <- lapply(1:nrow(points), function(x){assign_grid(points[x, ], grid)})
grid.pos <- unlist(IDs)
matched.IDs <- as.data.frame(grid.pos)
return(grid.pos)
}
#' Assign a grid ID to a particular lat/long point.
#' Used for points_to_matchedIDs and bb_to_matchedIDs.
#' @param fake_BOMdata A test set of temperatures.
#' @param noDays Number of days in the simulation.
#' @param tempdata Dataframe which includes the temp. deviate for each grid position
#' @return A dataframe of each grid position, its temperature deviate, and localised temperatures in that grid space over time.
assign_grid <- function(pos, grid){
close <- which((abs(pos$V2 - grid$V2) < gridSize) & abs(pos$V1 - grid$V1 < gridSize))
grid.match <- -1
if(length(close > 0)){
close.dist <- list(abs(pos$V2 - grid$V2[close]), abs(pos$V1 - grid$V1[close]))
closest    <- which(close.dist[[1]] == min(close.dist[[1]]) & close.dist[[2]] == min(close.dist[[2]]))
grid.match <- close[closest]
}
else if(length(close == 0)){
grid.match <- -1
}
return(grid.match)
}
bdary <- read.table("testboundary.txt", header=TRUE) # Boundary of simulation
houses <- read.table("pp_housing_data.txt", header=TRUE) #Location of houses
greenery.bdary <- read.table("greenery_bdary.txt", header=TRUE) #Bounding box of greenery area
martyn.bdary <- read.table("martyn_park_bdary.txt", header=TRUE) #Martyn sports park
tc.bdary <- read.table("martin_tennis_court.txt", sep=",", header=TRUE) #Tennis court next to Martyn sports park
# ---- Read in XML data from OSM/JOSM
newroads <- read.table("microclim/roads.txt", sep=",", header=TRUE) #11/02/20: with OSM street data, test
#newroads <- xmlToDataFrame("roadtest2.xml")
river  <- read.table("microclim/river.txt", sep=",", header=TRUE)
ogreen <- read.table("microclim/ogreen.txt", sep=",", header=TRUE)
oconc  <- read.table("microclim/concrete.txt", sep=",", header=TRUE)
trees  <- read.table("microclim/trees.txt", sep=",", header = TRUE)
builds <- read.table("microclim/buildings.txt", sep=",", header = TRUE)
fake_BOMdata <- c(21,23,25) # fake temps to apply deviates to
type_tempdevs <- c(1,-2,-1,7,5,-7) #fake tempdevs for each of the 6 land types- this is made up
noDays <- 3 # Number of days in simulation (just go with 3 for now)
noLandTypes <- 6 # Number of different land types we are considering
gridSize <- 0.00025 # Size of grid space: 0.00025 represents a 25m x 25m grid space
# ---- Construct grid of 25m x 25m spaces
grid <- make_grid(bdary, gridSize)
# ---- Determine location of houses
houses.sorted <- houses[with(houses, order(long)), ]
# this process is much the same as constructing 'grid' ----
houses.unique    <- unique(houses)
houses.in.region <- point.in.polygon(houses.unique$long, houses.unique$lat, bdary$long, bdary$lat)
final.houses     <- cbind(houses.unique$lat[which(houses.in.region ==1)], houses.unique$long[which(houses.in.region == 1)]) #puts these grid spaces into a df
final.houses    <- as.data.frame(final.houses)
houses.sorted <- unique(final.houses[order(final.houses$V2, final.houses$V1), ])
matched.IDs <- lapply(1:nrow(houses.sorted), function(x){assign_grid(houses.sorted[x, ], grid)})
grid.pos <- unlist(matched.IDs)
houses.matchedIDs <- as.data.frame(grid.pos)
greenery.matchedIDs <- bb_to_matchedIDs(greenery.bdary, gridSize, grid)
martyn.matchedIDs <- bb_to_matchedIDs(martyn.bdary, gridSize, grid)
tc.matchedIDs <- bb_to_matchedIDs(tc.bdary, gridSize, grid)
# ---- Determine grid spaces from data sets that are lists of points
severin.matchedIDs <- points_to_matchedIDs(severin.st, grid)
roads.matchedIDs <- points_to_matchedIDs(roads, grid)
# Below is testing from 11/02/20 osm node data test
osmroads.dt <- as.data.frame(cbind(newroads$X_lat, newroads$X_lon))
osmroads.matchedIDs <- as.data.frame(points_to_matchedIDs(osmroads.dt, grid))
osmroads.matchedIDs <- osmroads.matchedIDs[which(osmroads.matchedIDs != -1),] #remove any -1 entries
river.dt <- as.data.frame(cbind(river$X_lat, river$X_lon))
river.matchedIDs <- as.data.frame(points_to_matchedIDs(river.dt, grid))
river.matchedIDs <- river.matchedIDs[which(river.matchedIDs != -1),] #remove any -1 entries
ogreen.dt <- as.data.frame(cbind(ogreen$X_lat, ogreen$X_lon))
ogreen.matchedIDs <- as.data.frame(points_to_matchedIDs(ogreen.dt, grid))
ogreen.matchedIDs <- ogreen.matchedIDs[which(ogreen.matchedIDs != -1),] #remove any -1 entries
oconc.dt <- as.data.frame(cbind(oconc$X_lat, oconc$X_lon))
oconc.matchedIDs <- as.data.frame(points_to_matchedIDs(oconc.dt, grid))
oconc.matchedIDs <- oconc.matchedIDs[which(oconc.matchedIDs != -1),] #remove any -1 entries
trees.dt <- as.data.frame(cbind(trees$X_lat, trees$X_lon))
trees.matchedIDs <- as.data.frame(points_to_matchedIDs(trees.dt, grid))
trees.matchedIDs <- trees.matchedIDs[which(trees.matchedIDs != -1),] #remove any -1 entries
builds.dt <- as.data.frame(cbind(builds$X_lat, builds$X_lon))
builds.matchedIDs <- as.data.frame(points_to_matchedIDs(builds.dt, grid))
builds.matchedIDs <- builds.matchedIDs[which(builds.matchedIDs != -1),] #remove any -1 entries
# ---- Construct a dataframe of each grid space and land type
tempdata <- setNames(data.frame(matrix(ncol=4, nrow = nrow(grid))),c("Longitude","Latitude","LandType", "TemperatureDeviate"))
tempdata$Latitude <- grid$V1
tempdata$Longitude <- grid$V2
tempdata$TemperatureDeviate <- 0
tempdata$LandType <- 1
# ---- Set the different land types. There should be noLandTypes of land types
tempdata$LandType[unlist(greenery.matchedIDs)] <- 2
tempdata$LandType[unlist(martyn.matchedIDs)] <- 1
tempdata$LandType[unlist(tc.matchedIDs)] <- 3
#tempdata$LandType[unlist(severin.matchedIDs)] <- 5
#tempdata$LandType[unlist(roads.matchedIDs)] <- 5
tempdata$LandType[unlist(houses.matchedIDs)] <- 6
tempdata$LandType[unlist(osmroads.matchedIDs)] <- 3 #test 11/02/20 osm roads data
tempdata$LandType[unlist(river.matchedIDs)] <- 4 #test 11/02/20 osm river data
tempdata$LandType[unlist(ogreen.matchedIDs)] <- 1 #test 11/02/20 osm river data
tempdata$LandType[unlist(oconc.matchedIDs)] <- 3 #test 11/02/20 osm river data
tempdata$LandType[unlist(trees.matchedIDs)] <- 2 #test 11/02/20 osm river data
tempdata$LandType[unlist(builds.matchedIDs)] <- 5 #test 11/02/20 osm river data
# ---- Set the temperature deviates
for (i in 1:noLandTypes){
tempdata$TemperatureDeviate[which(tempdata$LandType == i)] <- type_tempdevs[i]
}
# ---- Construct the EKM chart
# 10/1/19: use dummy temperatures, this is just code copied from the package functions
dailyTemps <- c(20, 23, 25)
const      <- read.table("constants.txt", header=TRUE)
# Apply temperature deviates to daily temperatures for each land type
# Temperature at a particular land type = average daily temperature + its associated temperature deviate
landTypeTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
kelvinTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
for(i in 1:noLandTypes){
landTypeTemps[[i]] <- type_tempdevs[i] + dailyTemps
}
# Convert each temperature from Celsius to Kelvin
for(i in 1:noLandTypes){
kelvinTemps[[i]] <- type_tempdevs[i] + dailyTemps + const$KELV_CONV
}
# Converting kelvinTemps to a df for easy calculation
temp.df <- data.frame(matrix(unlist(kelvinTemps), nrow=length(kelvinTemps), byrow=T))
# ---- Calculating growth charts for each life stage
EKM_egg    <- 24*((const$RHO_E*(temp.df/298)*exp((const$HA_E/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_E/const$R)*(((1/const$THALF_E)-(1/temp.df))))))
EKM_larval <- 24*((const$RHO_L*(temp.df/298)*exp((const$HA_L/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_L/const$R)*(((1/const$THALF_L)-(1/temp.df))))))
EKM_pupal  <- 24*((const$RHO_P*(temp.df/298)*exp((const$HA_P/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_P/const$R)*(((1/const$THALF_P)-(1/temp.df))))))
EKM_gono   <- 24*((const$RHO_G*(temp.df/298)*exp((const$HA_G/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_G/const$R)*(((1/const$THALF_G)-(1/temp.df))))))
# To use this list, indexing works like: EKM_chart[[stage]][land_type, ][day]
EKM_chart  <- list(EKM_egg, EKM_larval, EKM_pupal, EKM_gono)
celineColours <- c("#4F6D5E","#F9E0D9","#F78A17")
ggtemp <- ggplot(data = tempdata, aes(x = Longitude, y = Latitude, fill = TemperatureDeviate)) +  geom_raster() + ggtitle("Example of temperature deviate structure") + theme(plot.title = element_text(hjust = 0.5)) +
scale_fill_gradientn(colours = celineColours) +
labs( fill = "Temp. deviate \n(Celsius)") +
theme(axis.text.x = element_blank(), axis.text.y = element_blank())#holy shit this actually works
ggtemp
# Created SMB 9/1/20
# Edited SMB 11/02/20
# The purpose of this script is to:
# 1) Consolidate the work I've already done
# 2) Tighten everything up since the other scripts have useless/antiquated code
# 3) See if there's anything I can do to clean the code up and make it less repetitve
# 4) Construct the EKM lookup table
# The EKM lookup table for microclimates is going to be deterministic with nested tables.
# The order will be: [stage][land type][day]
# So when we update the EKS for each agent, we add the value that is at dt[stage][land type][day]
# Eg: for an egg that is in land type 1 at time step t=2, we add the value at dt[0][1][2] to the agents' EKS
# Land type 0 is for NO temperature deviate effects; this is so we can turn temperature effects off.
# Grid spaces are 25m^2, if you ever see the number 0.00025 this is what it is referring to.
library(ggplot2)
library(data.table)
library(sp)
library(XML)
#' Applies a given temperature deviate to a list of daily temperatures.
#' This function is not used anymore.
#'
#' @param fake_BOMdata A test set of temperatures.
#' @param noDays Number of days in the simulation.
#' @param tempdata Dataframe which includes the temp. deviate for each grid position
#' @return A dataframe of each grid position, its temperature deviate, and localised temperatures in that grid space over time.
apply_tempdev <- function(fake_BOMdata, noDays, tempdata){
for(i in 1:noDays){
tempdata[, 3 + i] <- fake_BOMdata[i] + tempdata$TemperatureDeviate
}
return(tempdata)
}
# this is me sketching something for a full chart ----
#this function is not used anymore
apply_tempdev_chart <- function(fake_BOMdata, noDays, tempdata, stage){
for(i in 1:noDays){
tempdata[, 3 + i] <- fake_BOMdata[i] + tempdata$TemperatureDeviate
}
return(tempdata)
}
#' Converts a polygon boundary into a grid mesh, but in dataframe form
#'
#' @param bdary List of points along the boundary of the simulation area (in lat/long)
#' @param gridSize Grid size. Assumes square grid. In decimal form (eg 0.00025 = 25m^2 grid)
#' @return A dataframe of lat/long coordinates representing the region described by bdary
#'         with space sizes gridSize.
make_grid <- function(bdary, gridSize){
latval <- seq(min(bdary$lat), max(bdary$lat), gridSize)
longval <- seq(min(bdary$long), max(bdary$long), gridSize)
mesh <- expand.grid(latval,longval) #turns list of lat and long into grid
points <- point.in.polygon(mesh$Var1, mesh$Var2, bdary$lat, bdary$long) #identifies grid points that lie within our bounday: NB does not include those on the boundary
grid <- cbind(mesh$Var1[which(points==1)],mesh$Var2[which(points==1)]) #puts these grid spaces into a df
grid <- as.data.frame(grid)
return(grid)
}
#' Determines the grid ID number for each grid space within a bounding box.
#' Useful for, eg, large areas of greenery that we can easily draw a boundary
#'    around, instead of grabbing the lat/long of every point within the region.
#' Returns a dataframe of grid ID numbers that will be associated with that land type.
#'
#' @param bb Bounding box of region, in lat/long
#' @param gridSize Grid size. Assumes square grid. In decimal form (eg 0.00025 = 25m^2 grid)
#' @param grid Dataframe of area grid, as per what's created in make_grid
#' @return A dataframe of grid IDs associated with that land type.
bb_to_matchedIDs <- function(bb, gridSize, grid){
# Passing "grid" might be slow, but let's just do it for now so I can get this code done
mesh <- expand.grid(seq(min(bb$lat), max(bb$lat), gridSize), seq(min(bb$long), max(bb$long), gridSize))
points <- point.in.polygon(mesh$Var1, mesh$Var2, bb$lat, bb$long) #identifies grid points that lie within our bounday: NB does not include those on the boundary
bb.grid <- cbind(mesh$Var1[which(points > 0)], mesh$Var2[which(points > 0)]) #puts these grid spaces into a df
bb.grid <- unique(as.data.frame(bb.grid)) # Get rid of duplicates
matched.IDs <- lapply(1:nrow(bb.grid), function(x){assign_grid(bb.grid[x, ], grid)}) #the 'grid' is our simulation region 'grid'
grid.pos <- unlist(matched.IDs)
matched.IDs <- as.data.frame(grid.pos)
return(matched.IDs)
}
#' Determines the grid ID number corresponding to each lat/long point in the input.
#' Returns a dataframe of grid ID numbers that will be associated with that land type.
#'
#' @param points Lat/long points to be matched to a grid ID.
#' @param grid Dataframe of area grid, as per what's created in make_grid
#' @return A dataframe of grid IDs associated with that land type.
points_to_matchedIDs <- function(points, grid){
IDs <- lapply(1:nrow(points), function(x){assign_grid(points[x, ], grid)})
grid.pos <- unlist(IDs)
matched.IDs <- as.data.frame(grid.pos)
return(grid.pos)
}
#' Assign a grid ID to a particular lat/long point.
#' Used for points_to_matchedIDs and bb_to_matchedIDs.
#' @param fake_BOMdata A test set of temperatures.
#' @param noDays Number of days in the simulation.
#' @param tempdata Dataframe which includes the temp. deviate for each grid position
#' @return A dataframe of each grid position, its temperature deviate, and localised temperatures in that grid space over time.
assign_grid <- function(pos, grid){
close <- which((abs(pos$V2 - grid$V2) < gridSize) & abs(pos$V1 - grid$V1 < gridSize))
grid.match <- -1
if(length(close > 0)){
close.dist <- list(abs(pos$V2 - grid$V2[close]), abs(pos$V1 - grid$V1[close]))
closest    <- which(close.dist[[1]] == min(close.dist[[1]]) & close.dist[[2]] == min(close.dist[[2]]))
grid.match <- close[closest]
}
else if(length(close == 0)){
grid.match <- -1
}
return(grid.match)
}
# ---- Read in data, set parameters
bdary <- read.table("testboundary.txt", header=TRUE) # Boundary of simulation
houses <- read.table("pp_housing_data.txt", header=TRUE) #Location of houses
greenery.bdary <- read.table("greenery_bdary.txt", header=TRUE) #Bounding box of greenery area
martyn.bdary <- read.table("martyn_park_bdary.txt", header=TRUE) #Martyn sports park
tc.bdary <- read.table("martin_tennis_court.txt", sep=",", header=TRUE) #Tennis court next to Martyn sports park
#severin.st <- read.table("severinst.txt", sep=",", header=FALSE)
#roads <- read.table("roads.txt", sep=",", header=FALSE)
# ---- Read in XML data from OSM/JOSM
newroads <- read.table("microclim/roads.txt", sep=",", header=TRUE) #11/02/20: with OSM street data, test
#newroads <- xmlToDataFrame("roadtest2.xml")
river  <- read.table("microclim/river.txt", sep=",", header=TRUE)
ogreen <- read.table("microclim/ogreen.txt", sep=",", header=TRUE)
oconc  <- read.table("microclim/concrete.txt", sep=",", header=TRUE)
trees  <- read.table("microclim/trees.txt", sep=",", header = TRUE)
builds <- read.table("microclim/buildings.txt", sep=",", header = TRUE)
fake_BOMdata <- c(21,23,25) # fake temps to apply deviates to
type_tempdevs <- c(1,-2,-1,7,5,-7) #fake tempdevs for each of the 6 land types- this is made up
noDays <- 3 # Number of days in simulation (just go with 3 for now)
noLandTypes <- 7 # Number of different land types we are considering. includes 0 (no tempdev)
gridSize <- 0.00025 # Size of grid space: 0.00025 represents a 25m x 25m grid space
#
# ---- Construct grid of 25m x 25m spaces
grid <- make_grid(bdary, gridSize)
# ---- Determine location of houses
houses.sorted <- houses[with(houses, order(long)), ]
# this process is much the same as constructing 'grid' ----
houses.unique    <- unique(houses)
houses.in.region <- point.in.polygon(houses.unique$long, houses.unique$lat, bdary$long, bdary$lat)
final.houses     <- cbind(houses.unique$lat[which(houses.in.region ==1)], houses.unique$long[which(houses.in.region == 1)]) #puts these grid spaces into a df
final.houses    <- as.data.frame(final.houses)
houses.sorted <- unique(final.houses[order(final.houses$V2, final.houses$V1), ])
matched.IDs <- lapply(1:nrow(houses.sorted), function(x){assign_grid(houses.sorted[x, ], grid)})
grid.pos <- unlist(matched.IDs)
houses.matchedIDs <- as.data.frame(grid.pos)
# ---- Determine grid spaces from data sets that are bounding boxes
greenery.matchedIDs <- bb_to_matchedIDs(greenery.bdary, gridSize, grid)
martyn.matchedIDs <- bb_to_matchedIDs(martyn.bdary, gridSize, grid)
tc.matchedIDs <- bb_to_matchedIDs(tc.bdary, gridSize, grid)
# Below is testing from 11/02/20 osm node data test
osmroads.dt <- as.data.frame(cbind(newroads$X_lat, newroads$X_lon))
osmroads.matchedIDs <- as.data.frame(points_to_matchedIDs(osmroads.dt, grid))
osmroads.matchedIDs <- osmroads.matchedIDs[which(osmroads.matchedIDs != -1),] #remove any -1 entries
river.dt <- as.data.frame(cbind(river$X_lat, river$X_lon))
river.matchedIDs <- as.data.frame(points_to_matchedIDs(river.dt, grid))
river.matchedIDs <- river.matchedIDs[which(river.matchedIDs != -1),] #remove any -1 entries
ogreen.dt <- as.data.frame(cbind(ogreen$X_lat, ogreen$X_lon))
ogreen.matchedIDs <- as.data.frame(points_to_matchedIDs(ogreen.dt, grid))
ogreen.matchedIDs <- ogreen.matchedIDs[which(ogreen.matchedIDs != -1),] #remove any -1 entries
oconc.dt <- as.data.frame(cbind(oconc$X_lat, oconc$X_lon))
oconc.matchedIDs <- as.data.frame(points_to_matchedIDs(oconc.dt, grid))
oconc.matchedIDs <- oconc.matchedIDs[which(oconc.matchedIDs != -1),] #remove any -1 entries
trees.dt <- as.data.frame(cbind(trees$X_lat, trees$X_lon))
trees.matchedIDs <- as.data.frame(points_to_matchedIDs(trees.dt, grid))
trees.matchedIDs <- trees.matchedIDs[which(trees.matchedIDs != -1),] #remove any -1 entries
builds.dt <- as.data.frame(cbind(builds$X_lat, builds$X_lon))
builds.matchedIDs <- as.data.frame(points_to_matchedIDs(builds.dt, grid))
builds.matchedIDs <- builds.matchedIDs[which(builds.matchedIDs != -1),] #remove any -1 entries
# ---- Construct a dataframe of each grid space and land type
tempdata <- setNames(data.frame(matrix(ncol=4, nrow = nrow(grid))),c("Longitude","Latitude","LandType", "TemperatureDeviate"))
tempdata$Latitude <- grid$V1
tempdata$Longitude <- grid$V2
tempdata$TemperatureDeviate <- 0
#tempdata$LandType <- 1
tempdata$LandType  <- 0
# ---- Set the different land types. There should be noLandTypes of land types
tempdata$LandType[unlist(greenery.matchedIDs)] <- 2
tempdata$LandType[unlist(martyn.matchedIDs)] <- 1
tempdata$LandType[unlist(tc.matchedIDs)] <- 3
#tempdata$LandType[unlist(severin.matchedIDs)] <- 5
#tempdata$LandType[unlist(roads.matchedIDs)] <- 5
tempdata$LandType[unlist(houses.matchedIDs)] <- 6
tempdata$LandType[unlist(osmroads.matchedIDs)] <- 3 #test 11/02/20 osm roads data
tempdata$LandType[unlist(river.matchedIDs)] <- 4 #test 11/02/20 osm river data
tempdata$LandType[unlist(ogreen.matchedIDs)] <- 1 #test 11/02/20 osm river data
tempdata$LandType[unlist(oconc.matchedIDs)] <- 3 #test 11/02/20 osm river data
tempdata$LandType[unlist(trees.matchedIDs)] <- 2 #test 11/02/20 osm river data
tempdata$LandType[unlist(builds.matchedIDs)] <- 5 #test 11/02/20 osm river data
# ---- Set the temperature deviates
for (i in 1:noLandTypes){
tempdata$TemperatureDeviate[which(tempdata$LandType == i)] <- type_tempdevs[i]
}
# ---- Construct the EKM chart
# 10/1/19: use dummy temperatures, this is just code copied from the package functions
dailyTemps <- c(20, 23, 25)
const      <- read.table("constants.txt", header=TRUE)
# Apply temperature deviates to daily temperatures for each land type
# Temperature at a particular land type = average daily temperature + its associated temperature deviate
landTypeTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
kelvinTemps <- vector(mode = "list", length = noLandTypes) # Initialising lists
for(i in 1:noLandTypes){
landTypeTemps[[i]] <- type_tempdevs[i] + dailyTemps
}
# Convert each temperature from Celsius to Kelvin
for(i in 1:noLandTypes){
kelvinTemps[[i]] <- type_tempdevs[i] + dailyTemps + const$KELV_CONV
}
# Converting kelvinTemps to a df for easy calculation
temp.df <- data.frame(matrix(unlist(kelvinTemps), nrow=length(kelvinTemps), byrow=T))
# ---- Calculating growth charts for each life stage
EKM_egg    <- 24*((const$RHO_E*(temp.df/298)*exp((const$HA_E/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_E/const$R)*(((1/const$THALF_E)-(1/temp.df))))))
EKM_larval <- 24*((const$RHO_L*(temp.df/298)*exp((const$HA_L/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_L/const$R)*(((1/const$THALF_L)-(1/temp.df))))))
EKM_pupal  <- 24*((const$RHO_P*(temp.df/298)*exp((const$HA_P/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_P/const$R)*(((1/const$THALF_P)-(1/temp.df))))))
EKM_gono   <- 24*((const$RHO_G*(temp.df/298)*exp((const$HA_G/const$R)*((1/298) - (1/temp.df))))/(1 + exp((const$HH_G/const$R)*(((1/const$THALF_G)-(1/temp.df))))))
# To use this list, indexing works like: EKM_chart[[stage]][land_type, ][day]
EKM_chart  <- list(EKM_egg, EKM_larval, EKM_pupal, EKM_gono)
celineColours <- c("#4F6D5E","#F9E0D9","#F78A17")
ggtemp <- ggplot(data = tempdata, aes(x = Longitude, y = Latitude, fill = TemperatureDeviate)) +  geom_raster() + ggtitle("Example of temperature deviate structure") + theme(plot.title = element_text(hjust = 0.5)) +
scale_fill_gradientn(colours = celineColours) +
labs( fill = "Temp. deviate \n(Celsius)") +
theme(axis.text.x = element_blank(), axis.text.y = element_blank())#holy shit this actually works
ggtemp
