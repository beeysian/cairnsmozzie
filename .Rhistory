# Step 8: Update numerical 'age' of agent ----
juv.dt$age    <- mapply('+', juv.dt$age, 1)
mozzie.dt$age <- mapply('+', mozzie.dt$age, 1)
#  s8 <- s8 +1 #debugging
# End Step 8
# Step 9: Mosquito releases ----
today.releases <- list()
#Check if it's one of the days where there is a mosquito release
if(t %in% release.days$day){
#For each day where a release was held, there are multiple releases in multiple locations
#So we need to iterate through all of them.
#Ideally, we should be able to replace this for loop with some vectorised code.
temp.releases <- releaseDat[which(releaseDat$Day == t),] # Rows of releaseDat corresponding to today's releases
rownames(temp.releases) <- 1:nrow(temp.releases)
# We will run initialise_releases for each line of today.releases
for(i in 1:nrow(temp.releases)){
if(as.integer(temp.releases$NoMozzie[i] > 0)){
today.releases <- rbind(today.releases, initialise_release(as.integer(temp.releases$NoMozzie[i]), temp.releases$NoMale[i], temp.releases$NoFemale[i], temp.releases$Lat[i], temp.releases$Long[i], idStart, temp.releases$GID[i]))
idStart        <- idStart + as.integer(temp.releases$NoMozzie[i]) + 1 #So we keep track of the right mosquito ID number
}
}
# Mozzies all need to have a dispersal event at time of release
# TO DO: update gridID as well!!!! *
# Idea: perhaps try to do this in constructor? Not sure which one is faster
today.releases.disp <- mapply(FUN = random_dispersal, today.releases$lat, today.releases$long, param$lambda) #DOES THIS WORK? LOL
today.releases.disp <- do.call(rbind, today.releases.disp)
today.releases.lat  <- today.releases.disp[c(TRUE, FALSE)]
today.releases.long <- today.releases.disp[c(FALSE, TRUE)]
today.releases$lat  <- today.releases.lat
today.releases$long <- today.releases.long
l         <- list(mozzie.dt, today.releases)
mozzie.dt <- rbindlist(l, use.names = TRUE)
rm(l)
rm(today.releases)
rm(today.releases.disp)
rm(today.releases.lat)
rm(today.releases.long)
}
# s9 <- s9 + 1 #debugging
# End Step 9 ----
# End of timestep procedures ----
# To do: make the below into a function
if(length(which(mozzie.dt$infStatus == 0)) == 0){
inf.prop[t] <- 1
}else if(length(which(mozzie.dt$infStatus == 1)) == 0){
inf.prop[t] <- 0
}else{
inf.prop[t] <- length(which(mozzie.dt$infStatus == 1))/nrow(mozzie.dt)
}
if(nrow(graveyard) > 0){
if(length(which(graveyard$infStatus == 0)) == 0){
grav.inf.prop[t] <- 1
}else if(length(which(graveyard$infStatus == 1)) == 0){
grav.inf.prop[t] <- 0
}else{
grav.inf.prop[t] <- length(which(graveyard$infStatus == 1))/nrow(graveyard)
}
}else{
grav.inf.prop[t] <- 0
}
pb$tick() # This is for the progress bar
}
# Read in data files ----
boundaryDat <- read.table("inst/exdata/New_pp_Bound.txt", header=TRUE) #Boundary data for the boundary of the area used in trial (given as a set of lat/long points)
boundary.bb <- read.table("inst/exdata/testboundary.txt", header=TRUE) # Bounding box of boundary, used for microclimates
minTemp     <- read.table("inst/exdata/cairnsAero_minTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
maxTemp     <- read.table("inst/exdata/cairnsAero_maxTemp.txt", header=TRUE) #Weather data over 90 days as provided by BOM
const       <- read.table("inst/exdata/constants.txt", header=TRUE) #constants used for EKM calculations
releaseDat  <- read.table("inst/exdata/PP_release.txt", header=TRUE) #Data regarding mosquito releases
trappingDat <- read.table("inst/exdata/PP_trapping_data.txt", sep=",", header=TRUE) #Trapping data for mosquitoes
# End reading in files
# Set global constants ----
max_age         <- 30 #mozzies who reach this age automatically die naturally
max_juv_age     <- 14 #juveniles who reach this age automatically become adults
max_pop_size    <- 100000 #if adult population exceeds this size, terminate simulation
init_prop_inf   <- 0 #initial proportion of wild mozzies carrying Wolbachia- we expect this to be 0
max_daily_mates <- 2 #maximum number of mating events a MALE mosquito can have in a day (from literature)
include_microclimates <- 0 #Set to 1 to include microclimates effect, 0 to not include
gridSize        <- 0.00025 # Size of grid spacing for microclimates
noLandTypes     <- 7 # Number of land types considered in microclimate analysis
typeTempDevs    <- c(1,-2,-1,10,5,-3, 2) # Temperature deviates for each land type- FIX (should be read in)
# End global constants
# For testing: alternative values of parameters ----
#lambda <- rgamma(1,shape=0.044,scale=3) #CHECK/CHANGE THIS omg i don't know how the Gamma distribution works
#lambda <- rgamma(1,3,22) #this is the alternative for lambda given in priors.pdf. Seems to give reasonable results with lat/long conversion so tempted to go with
#pmale <- runif(1,0.3,0.7) #can also set to be 0.45
#OR pmale <- rnorm(1,mean=0.5,sd=0.02) ??? check with Carla which one
# k <-  rgamma(1,shape=0.2,scale=0.06) #CHANGE THIS #rate at which probability of mating drops wrt distance of potential mate
#k <- rgamma(1,1,1/35) #rate at which probability of mating drops wrt distance of potential mate
#WMP say that the following two values of eta are wrong/too high: so will put lower ones below
#eta_1 <- round(rnorm(1,mean=120,sd=7),0) #no. of offspring produced by Wb non-carrier mothers (values from literature)
#eta_2 <- round(rnorm(1,mean=70,sd=5),0) #no. of offspring produced by Wb carrier mothers (values from literature)
#To re-iterate, these are MADE UP and need validifying
#eta_1 <- round(rnorm(1,mean=40,sd=7),0) #no. of offspring produced by Wb non-carrier mothers
#eta_2 <- round(rnorm(1,mean=30,sd=5),0) #no. of offspring produced by Wb carrier mothers
#p_1 = runif(1,0,0.05)
# Parameter generation for RABC ----
param <- data.frame(lambda = rgamma(1,3,22),
pmale = 0.45, #proportion of male mosquitoes in wild population: FIXED
k = rgamma(1,shape=1,scale=1/35),
phi = runif(1,0.00001,0.001), #hyperparameter for probability that mozzies are trapped by any given trap
a = rtruncnorm(1,mean=0.02,sd=0.01,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
b = rtruncnorm(1,mean=0.22,sd=0.05,a=0,b=0.5), #Scale parameter regarding probability of natural death (Gompertz model)
alpha_a = 0.2, #adult mortality rate, approx. from literature (0.2 is made up)
alpha_j = 0.3, #juvenile mortality rate: this is made up
p_1 = 1, #Probability of complete maternal transmission (virtually 100% according to Ross '16 & '17)
eta_1 = round(rnorm(1,mean=40,sd=7),0), #no. of offspring produced by Wb non-carrier mothers
eta_2 = 0) #this was changed 8/1/20: Dutra15 and Ant18 imply eta_1 = eta_2
#eta_2 = round(rnorm(1,mean=30,sd=5),0)) #no. of offspring produced by Wb carrier mothers
param$eta_2 <- param$eta_1 # Dutra15 and Ant18 imply eta_1 = eta_2
# End of parameter generation
# Variable initialisation ----
N       <- 20000 #number of adult mosquitoes at time t=0. To be initialised between 4000 to 20000
Njuv    <- 1000 #number of juvenile CLUSTERS (not individuals) at time t=0
idStart <- N+1 #ID numbers of initial adults will be 1:N, then we start at N+1 for any new adult mosquito within simulation
noTimeSteps <- 90 #our simulation runs for 90 days
t <- 0 #timestep; starts from 0.
# End variable initialisation
# Calculate temperature and growth charts ----
#Chart of average daily temperatures for each day of the simulation
dailyTemps <- temperature_chart(minTemp, maxTemp, noTimeSteps)
# If we're running microclimates, set them up ----
if(include_microclimates == 1){
print("Simulation includes microclimates")
# Realistic microclimates
EKMChart <- initialise_enzyme_wmicroclim(boundary.bb, dailyTemps, typeTempDevs, noTimeSteps, noLandTypes, gridSize, const)
} else if(include_microclimates == 0){
print("No microclimates in simulation")
EKMChart <- initialize_enzyme(dailyTemps) #chart of daily updates for EKS
}
# End microclimate setup
# End chart calculation
# Set up trap locations and clean trapping data ----
trapClean       <- trap_clean(trappingDat) # Clean trapping data
trapLoc         <- trap_setup(trapClean) # Dataframe of trap locations in lat/long
number_of_traps <- length(trapLoc$V1) # Number of traps in simulation
daily_trapped   <- list() #Placeholder for real trapping output data
# End trapping data setup ----
# Wrangling of release data used in simulation ----
releaseDat   <- release_clean(releaseDat) #Cleaning release data
release.days <- as.data.frame(table(day = releaseDat$Day)) #Grabbing days that releases were made
# End of release data wrangling
# Set up grid- even if no microclimates used ----
grid.df <- make_grid(boundary.bb, gridSize)
# End grid setup
# Model initialisation/construction ----
mozzie.dt     <- as.data.table(initialise_adults(N, param$pmale)) #initial adult population
juv.dt        <- as.data.table(initialise_juveniles(Njuv)) #initial juvenile population
graveyard     <- initialise_graveyard() # Where entries of dead mosquitoes go.
juv.graveyard <- initialise_juv_graveyard() # Where entries of eggs with CI go
# End initial model construction
# Initialising data output ----
# Vector to keep track of Wolbachia infection proportion over time
inf.prop      <- rep(0, noTimeSteps) # Proportion of Wb infection over time: alive adults
grav.inf.prop <- rep(0, noTimeSteps) # Proportion of Wb infection from trapped mozzies.
# End data output initialisation ----
# Below is for debugging/identifying where things mucked up ----
#s1 <- 0
#s2 <- 0
#s3 <- 0
#s4 <- 0
#s5 <- 0
#s6 <- 0
#s7 <- 0
#s8 <- 0
#s9 <- 0
# end debugging variables ----
t <- 1
pb <- progress_bar$new(format = " elapsed [:bar] :percent elapsed: :elapsed eta: :eta", total = noTimeSteps) #progress bar
for(t in 1:noTimeSteps){
# Step 1: Juvenile emergence -----
to.adult <- which(juv.dt$stage == 3 & juv.dt$enzyme > 0.95)
# to.migrate <- NULL # This will be updated if we have any emerging agents
if((length(to.adult)) != 0){
new.adults.dt <- mapply(FUN=juv_to_adult, to.adult, idStart, param$pmale, param$lambda, SIMPLIFY = FALSE)
new.adults.dt %<>% rbindlist() %>% as.data.table()
mozzie.dt     <<- rbind(mozzie.dt, new.adults.dt)
#delete row(s) of data table corresponding to the clutches that aged into adult mozzies
juv.dt        <<- juv.dt[-to.adult]
#  to.migrate    <- seq(idStart,idStart + length(new.adults.dt) -1) # Since all mozzies that have just emerged get to migrate CHECK
idStart       <- idStart + nrow(new.adults.dt) + 1 # So we ID mosquitoes correctly
rm(new.adults.dt)
}
# Step 1.5: any juveniles moving to the next development stage? ----
# If enzyme > 0.95, move on to the next development stage and reset enzyme score
if(length(which(juv.dt$enzyme > 0.95)) > 0){
#which(juvdf$enzyme > 0.95)
juv.dt[which(juv.dt$enzyme > 0.95)]$stage  <- juv.dt[which(juv.dt$enzyme > 0.95)]$stage + 1
#this gives HELLA warnings- try mapply or lapply or something?
juv.dt[which(juv.dt$enzyme > 0.95)]$enzyme <- 0
#juvdf[which(juvdf$enzyme > 0.95)]$stage <- lapply(juvdf[which(juvdf$enzyme > 0.95)]$stage, function(x) x <- juvdf$enzyme[x] <- 0)
}
# End Step 1.5
rm(to.adult)
#If adult population size now exceeds max_pop_size, kill the simulation
if(nrow(mozzie.dt) > max_pop_size){
print("Termination condition 1: Maximum population size exceeded")
break
}
#  s1 <- s1 +1 #debugging
# End Step 1
# Step 2: Egg laying ----
#Determine which mothers will lay their eggs today
#Conditions to be satisfied for a mother to lay a clutch of eggs:
## 1) Has a mate
## 2) Enzyme Kinetic Score > 1 (should mean that mosquito has a mate)
## 3) First egg laying event is at EKS > 1, second at 1.58,
##    third at 2.16, etc. for multiples of 0.58 (from Focks et al '93)
to.lay <- which(mozzie.dt$gender == 1 & mozzie.dt$mateID != -1 & ((mozzie.dt$enzyme >= 1 & mozzie.dt$gonoCycle == 0) | (mozzie.dt$enzyme >= 1.58 & mozzie.dt$gonoCycle == 1) | (mozzie.dt$enzyme >= 2.16 & mozzie.dt$gonoCycle == 2)))
if(length(to.lay) != 0){
# Create new egg entries
new.eggs.dt <- initialise_eggs(to.lay, param$eta_1, param$eta_2, param$p_1, param$alpha_j)
# If there are egg clutches with CI, remove them and add to juv.graveyard
to.CI <- which(new.eggs.dt$infProb == -1)
if(length(to.CI) > 0){
# Adding eggs with CI to the juv.graveyard
l             <- list(juv.graveyard, new.eggs.dt[to.CI])
juv.graveyard <- rbindlist(l, use.names = TRUE)
# Remove CI eggs from new.eggs.dt
new.eggs.dt <- new.eggs.dt[!(to.CI)]
rm(l)
}
# Add new eggs to the juvenile data.table
juv.dt      <- rbind(juv.dt,new.eggs.dt)
rm(new.eggs.dt)
rm(to.CI)
}
rm(to.lay) #Remove to.lay
#  s2 <- s2 +1 #debugging
# End Step 2
# Step 3: Do we have mosquitoes being trapped (and killed?) ----
# to.trap <- list()
for(i in 1:number_of_traps){
to.trap <- list()
temptrap <- find_trapped(trapLoc$V1[i], trapLoc$V2[i], param$phi, mozzie.dt)
if(length(temptrap)> 1 && temptrap[1] != -1){
#if this is slow, work out how to use rbindlist
#to.trap <- rbind(to.trap, temptrap)
if(i == 1){
to.trap <- temptrap
mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
# mozzie.dt[mozzie.dt$ID %in% to.trap,]$typeDeath <- 1 # Type of death is trapped death
#  mozzie.dt[mozzie.dt$ID %in% to.trap,]$timeDeath <- t # They died today
}else{to.trap <- append(to.trap, temptrap)
mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
#     mozzie.dt[mozzie.dt$ID %in% to.trap,]$typeDeath <- 1 # Type of death is trapped death
#    mozzie.dt[mozzie.dt$ID %in% to.trap,]$timeDeath <- t # They died today
}
# Updating the entries of mozzies that have been trapped
#print("There are trapped mozzies")
to.trap <- unlist(to.trap)
#print(to.trap)
#print(class(to.trap))
mozzie.dt[mozzie.dt$ID %in% to.trap,]$typeDeath <- 1 # Type of death is trapped death
mozzie.dt[mozzie.dt$ID %in% to.trap,]$timeDeath <- t # They died today
#to.trap   <- unique(to.trap) #in case there are duplicates
l         <- list(graveyard, mozzie.dt[mozzie.dt$ID %in% to.trap,])
graveyard <- rbindlist(l) # Trapped mozzies go in the graveyard!
#THE BELOW LINE NEEDS FIXING/TO WORK
# mozzie.dt <- mozzie.dt[-(mozzie.dt$ID %in% to.trap)]# Delete entries of mozzies who have been trapped and killed
mozzie.dt <- mozzie.dt[!(mozzie.dt$ID %in% to.trap)]# Delete entries of mozzies who have been trapped and killed
rm(l)
}
rm(temptrap)
# rm(l)
}
# line of code for testing: this removes all functional duplicates:
## test <- graveyard[!duplicated(graveyard[,!c('whereTrapped')]),]
#For fun: plotting traps and agent locations
#bdary <- read.table("inst/exdata/testboundary.txt", sep=" ", header=TRUE) #read in data
#trapp <- ggplot(trapLoc, aes(x=V1, y=V2)) + geom_point()
#trapp + geom_point(data=mozzie.dt, aes(x=mozzie.dt$lat, y=mozzie.dt$long, color="red")) +
#geom_path(data = boundary.bb, aes(x=boundary.bb$lat, y=boundary.bb$long, color="green")) +
#geom_path(data = boundaryDat, aes(x = boundaryDat$Lat, y=boundaryDat$Long, color="blue"))
#  s3 <- s3 + 1 #debugging
if(nrow(mozzie.dt) == 0){
print("Termination condition 3: All adults have died (traps)")
break
}
# End Step 3
# Step 4: Natural mosquito death (juvenile and adult) ----
##Juvenile natural death: remove 10% of the population
##The subsetting of juvdf$clutchSize is because we don't reduce clutch size of CI-affected eggs:
## they're already dead, but we just want to track how many there are so we leave clutchSize alone
juv.dt$clutchSize[which(juv.dt$pDeath != -1)] <- mapply(FUN = resize_clutch,juv.dt$clutchSize, param$alpha_j)
# Remove juvenile agents where clutchSize == 0.
# We don't need the information but let's put them in the graveyard anyway.
dead.clutch <- which(juv.dt$clutchSize == 0)
if(length(dead.clutch) > 0){
l <- list(juv.graveyard, juv.dt[dead.clutch,]) #List of dead mozzies to remove
juv.graveyard <- rbindlist(l, use.names = TRUE)
juv.dt <- juv.dt[!(dead.clutch)]
rm(l)
}
rm(dead.clutch)
##Adult death:
##Adults die automatically when they reach age 40
##Vector of mosquitoes that will die of old age
to.old.die <- which(mozzie.dt$age == max_age & mozzie.dt$timeDeath == -1)
if((length(to.old.die)) != 0){
#Track day that they died (timeDeath) and set typeDeath = 0 to denote natural (not trapped) death
mozzie.dt$typeDeath[to.old.die] <- 0
mozzie.dt$timeDeath[to.old.die] <- t
mozzie.dt <- mozzie.dt[!to.old.die,]
}
rm(to.old.die)
##Adults can also die as per natural death rate
#mozzie.dt <- mozzie.dt[!sample(.N, round(param$alpha_a*nrow(mozzie.dt)))]
to.nat.die <- mozzie.dt[sample(.N, round(param$alpha_a*nrow(mozzie.dt)))]
#ADD THE FOLLOWING TWO LINES BACK FOR MAIN SIM
#mozzie.dt[mozzie.dt$ID %in% to.trap,]$whereTrapped <- trapLoc$V3[i]
if(length(to.nat.die) >= 1){
mozzie.dt[mozzie.dt$ID %in% to.nat.die$ID,]$typeDeath <- 0
mozzie.dt[mozzie.dt$ID %in% to.nat.die$ID,]$timeDeath <- t
l <- list(graveyard, mozzie.dt[mozzie.dt$ID %in% to.nat.die$ID,]) #List of dead mozzies to remove
graveyard <- rbindlist(l, use.names = TRUE)
mozzie.dt <- mozzie.dt[!(mozzie.dt$ID %in% to.nat.die$ID)] #removing naturally dead mozzies from mozzie.dt
rm(to.nat.die)
rm(l)
}
if(nrow(mozzie.dt) == 0){
print("Termination condition 2: All adults have died (natural)")
break
}
#  s4 <- s4 + 1 #debugging
# End step 4 ----
# Step 5: Mosquito mating ----
#We only need to find mates for:
## Females that don't have mates and haven't laid eggs yet (first gono cycle)
## AND has EKS >= 1 (From Focks)
# to.mate <- which((mozzie.dt$gender == 1 & mozzie.dt$mateID == -1 & mozzie.dt$gonoCycle == 0 & mozzie.dt$enzyme >= 1))
#  if(length(to.mate) != 0){
#    print(mozzie.dt)
#    new.mate.IDs <- mapply(FUN = find_mate, to.mate, param$k, max_daily_mates, mozzie.dt)
#    mozzie.dt$mateID[to.mate] <- mapply(FUN = find_mate, to.mate, param$k, max_daily_mates, mozzie.dt)
#for testing: gives the vector of mate IDs for the bachelorette mosquitoes
#try <- mapply(FUN=findMate,toMate,k)
#  }
#  rm(to.mate)
##For male agents, gonoCycle has a different purpose:
#Resetting gonoCycle for the next day for male agents since gonoCycle tracks
#  mozzie.dt$gonoCycle[which(mozzie.dt$gender == 0)] <- 0
# Step 5 try 2: find_mate isn't working anymore since passing mozzie.dt doesn't actually pass the data.table
# which makes everything really frustrating. so i'll just do a loop for now :/
#We only need to find mates for:
## Females that don't have mates and haven't laid eggs yet (first gono cycle)
## AND has EKS >= 1 (From Focks)
to.mate <- which((mozzie.dt$gender == 1 & mozzie.dt$mateID == -1 & mozzie.dt$gonoCycle == 0 & mozzie.dt$enzyme >= 1))
if(length(to.mate) != 0){
for(m in 1:length(to.mate)){
to.mate.pos <- as.numeric(c("lat"  = mozzie.dt$lat[to.mate[m]],
"long" = mozzie.dt$long[to.mate[m]]))
# The below needs to be changed from 0.00011 to the parameter k
to.mate.bdary    <- c("latmin" = to.mate.pos[1]-0.00011, "latmax" = to.mate.pos[1]+0.00011,
"longmin" = to.mate.pos[2]-0.00011 , "longmax" = to.mate.pos[2]+0.00011)
possible.mates <- which(mozzie.dt$lat >= to.mate.bdary["latmin"] & mozzie.dt$lat <= to.mate.bdary["latmax"] & mozzie.dt$long >= to.mate.bdary["longmin"] & mozzie.dt$long <= to.mate.bdary["longmax"] & mozzie.dt$gender == 0)
no.bachelors   <- length(possible.mates)
if(no.bachelors == 0){
new.mate <- -1
#print(paste0(to.mate[m], " no mate found"))
}else if(no.bachelors == 1){
if(mozzie.dt[possible.mates]$gonoCycle >= max_daily_mates){
new.mate <- -1 #even though there is only one male, he has mated too much today
# print(paste0(femID, " 1 mate found, unsuitable"))
}else{
new.mate <- as.integer(possible.mates)
mozzie.dt$gonoCycle[new.mate] <- mozzie.dt$gonoCycle[new.mate] + 1
#return(mozziedf$ID[possible.mates]) #New mate is just the single male they found
#print(paste0(femID, " 1 mate found"))
}
}else{
if(length(which(mozzie.dt[possible.mates]$gonoCycle >= max_daily_mates)) == 0){
#Randomly permutes the list of possible mates and then picks the one at the top of the pile
new.mate <- sample(possible.mates)[1]
#Increment number of mates of male by 1
mozzie.dt$gonoCycle[new.mate] <- mozzie.dt$gonoCycle[new.mate] + 1
#print(paste0(femID, " multiple mates, all ok"))
}else{
#Remove males who have mated more than "max_daily_mates" number of times in a day
possible.mates <- possible.mates[-(which(mozzie.dt[possible.mates]$gonoCycle >= max_daily_mates))]
#Now we have one more condition to check for:
##If we drop some males from "possible.mates" we might end up dropping them all,
##so if we dropped them all we return -1
if(length(possible.mates) == 0){
#print(paste0(femID, " multiple mates, had to drop some AND then ended up with none"))
new.mate <- 1
}else{
#Randomly permutes the list of possible mates and then picks the one at the top of the pile
new.mate <- sample(possible.mates)[1]
mozzie.dt$gonoCycle[new.mate] <- mozzie.dt$gonoCycle[new.mate] + 1 #increment number of mates by 1
# print(paste0(femID, " multiple mates, had to drop some"))
}
}
}
mozzie.dt$mateID[to.mate[m]] <- new.mate
rm(to.mate.pos)
rm(to.mate.bdary)
rm(possible.mates)
rm(no.bachelors)
new.mate <- -1
}
}
rm(to.mate)
##For male agents, gonoCycle has a different purpose:
#Resetting gonoCycle for the next day for male agents since gonoCycle tracks
mozzie.dt$gonoCycle[which(mozzie.dt$gender == 0)] <- 0
#  s5 <- s5 +1 #debugging
# End Step 5
# Step 6: Updating Enzyme Kinetic Score for each agent ----
##Update EKS for juvenile agents
juv.enzyme.update <- mapply(FUN = update_enzyme, juv.dt$stage, t)
#This is a super hacky method....
juv.dt$enzyme <- as.numeric(juv.dt$enzyme) + as.numeric(juv.enzyme.update)
##Update EKS for adult agents
##Adult mosquitoes always update with the same EKM formula, hence are always in "stage 4"
mozzie.enzyme.update <- mapply(FUN = update_enzyme, 4, t)
mozzie.dt$enzyme <- as.numeric(mozzie.dt$enzyme) + as.numeric(mozzie.enzyme.update)
rm(juv.enzyme.update)
rm(mozzie.enzyme.update)
#  s6 <- s6 + 1 #debugging
# End Step 6
# Step 7: Mosquito dispersal ----
##Determine which mosquitoes are going to migrate
#to.migrate <- which(mozzie.dt$age == 19) #CHANGE
#to.migrate is now determined when we do juvenile emergence (CHECK Step 1)
# ---- the below was commented out on 27/2/20 ----
#  if(length(to.migrate) != 0){
#CHECK this works with length(toMigrate) > 1
#    update.disp <- mapply(FUN = random_dispersal, mozzie.dt$lat[to.migrate], mozzie.dt$long[to.migrate], param$lambda)
#    update.disp <- do.call(rbind, update.disp)
#Suppressing warnings for this assignment at the moment:
##this operation coerces a list to a double, going from a precision of 47 dp to 45 dp.
##However for lat/long any value to more than 10 dp is fairly nonsensical (sub milimetre) so we don't care
#   suppressWarnings(mozzie.dt[to.migrate, "lat" := update.disp[1,]])
#    suppressWarnings(mozzie.dt[to.migrate, "long" := update.disp[2,]])
#   rm(update.disp)
#  }
#rm(to.migrate)
# ---- uncomment the above if we want to add a second migration event
#  s7 <- s7 +1 #debugging
# End Step 7
# Step 8: Update numerical 'age' of agent ----
juv.dt$age    <- mapply('+', juv.dt$age, 1)
mozzie.dt$age <- mapply('+', mozzie.dt$age, 1)
#  s8 <- s8 +1 #debugging
# End Step 8
# Step 9: Mosquito releases ----
today.releases <- list()
#Check if it's one of the days where there is a mosquito release
if(t %in% release.days$day){
#For each day where a release was held, there are multiple releases in multiple locations
#So we need to iterate through all of them.
#Ideally, we should be able to replace this for loop with some vectorised code.
temp.releases <- releaseDat[which(releaseDat$Day == t),] # Rows of releaseDat corresponding to today's releases
rownames(temp.releases) <- 1:nrow(temp.releases)
# We will run initialise_releases for each line of today.releases
for(i in 1:nrow(temp.releases)){
if(as.integer(temp.releases$NoMozzie[i] > 0)){
today.releases <- rbind(today.releases, initialise_release(as.integer(temp.releases$NoMozzie[i]), temp.releases$NoMale[i], temp.releases$NoFemale[i], temp.releases$Lat[i], temp.releases$Long[i], idStart, temp.releases$GID[i]))
idStart        <- idStart + as.integer(temp.releases$NoMozzie[i]) + 1 #So we keep track of the right mosquito ID number
}
}
# Mozzies all need to have a dispersal event at time of release
# TO DO: update gridID as well!!!! *
# Idea: perhaps try to do this in constructor? Not sure which one is faster
today.releases.disp <- mapply(FUN = random_dispersal, today.releases$lat, today.releases$long, param$lambda) #DOES THIS WORK? LOL
today.releases.disp <- do.call(rbind, today.releases.disp)
today.releases.lat  <- today.releases.disp[c(TRUE, FALSE)]
today.releases.long <- today.releases.disp[c(FALSE, TRUE)]
today.releases$lat  <- today.releases.lat
today.releases$long <- today.releases.long
l         <- list(mozzie.dt, today.releases)
mozzie.dt <- rbindlist(l, use.names = TRUE)
rm(l)
rm(today.releases)
rm(today.releases.disp)
rm(today.releases.lat)
rm(today.releases.long)
}
# s9 <- s9 + 1 #debugging
# End Step 9 ----
# End of timestep procedures ----
# To do: make the below into a function
if(length(which(mozzie.dt$infStatus == 0)) == 0){
inf.prop[t] <- 1
}else if(length(which(mozzie.dt$infStatus == 1)) == 0){
inf.prop[t] <- 0
}else{
inf.prop[t] <- length(which(mozzie.dt$infStatus == 1))/nrow(mozzie.dt)
}
if(nrow(graveyard) > 0){
if(length(which(graveyard$infStatus == 0)) == 0){
grav.inf.prop[t] <- 1
}else if(length(which(graveyard$infStatus == 1)) == 0){
grav.inf.prop[t] <- 0
}else{
grav.inf.prop[t] <- length(which(graveyard$infStatus == 1))/nrow(graveyard)
}
}else{
grav.inf.prop[t] <- 0
}
pb$tick() # This is for the progress bar
}
grav.inf.prop
inf.prop
# Realistic microclimates
EKMChart <- initialise_enzyme_wmicroclim(boundary.bb, dailyTemps, typeTempDevs, noTimeSteps, noLandTypes, gridSize, const)
View(EKMChart)
EKMChart[[4]][2, ][30]
typeof(EKMChart[[4]][2, ][30])
View(grid.df)
EKMChart[[4]][3, ][30]
